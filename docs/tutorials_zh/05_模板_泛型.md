# 模板与泛型（给初学者）

本篇解释 Prajna 的“泛型”（模板）能力：如何编写对“类型”和“编译期常量”都通用的代码，并结合数组/张量与接口实现给出实战示例。

你将学到：
- 泛型结构体与方法：`template <T>`、`implement Box<T>`
- 泛型函数：以类型参数编写可复用算法
- 模板“常量参数”：如 `Length_`、`Dim` 等编译期整数
- 为“泛型类型的实例”实现接口（多态的组合）
- 类型别名与可读性
- 常见坑与练习

## 1. 泛型结构体与方法

定义：在类型名上引入“类型参数”，使结构体对多种数据类型通用。

```prajna
template <T>
struct Box { value: T; }

// 给泛型结构体实现方法，方法同样依赖类型参数 T
implement Box<T> {
    func Get()->T { return this.value; }
    func Set(v: T) { this.value = v; }
}

func Main(){
    var i: Box<i64>; i.value = 42i64; i.Get().PrintLine();
    var s: Box<String>; s.value = "Hi"; s.Get().PrintLine();
}
```

要点：
- `template <T>` 声明类型参数 T；使用时显式写出具体类型：`Box<i64>`、`Box<String>`
- 在 `implement` 上同样带上 `<T>`，表明这些方法适用于所有 `Box<T>`

## 2. 泛型函数

定义：在函数上引入“类型参数”，让函数能处理不同类型的参数，只要它们满足函数体中使用的操作。

```prajna
template <T>
func Swap(a: ptr<T>, b: ptr<T>) {
    var tmp = *a;
    *a = *b;
    *b = tmp;
}

func Main(){
    var x = 1i64; var y = 2i64; Swap<i64>(&x, &y);
    var s1 = "A"; var s2 = "B"; Swap<String>(&s1, &s2);
}
```

提示：
- 需显式给出类型实参（如 `Swap<i64>`），以保证类型清晰
- 函数体内对 `T` 的操作必须对“替换进来的类型”是合法的（如可赋值）

## 3. 模板“常量参数”（编译期整数）

定义：除“类型参数”外，还可传入编译期整数，常用于“长度/维度”等场景。

```prajna
template <Type, Length_>
struct FixedVec { data: Array<Type, Length_>; }

implement <Type, Length_> FixedVec<Type, Length_> {
    func At(i: i64)->Type { return this.data[i]; }
}

func Main(){
    var v: FixedVec<i64, 4>;
    // v.data 的类型是 Array<i64, 4>
}
```

常见用法：
- 定长数组：`Array<Type, Length_>`（见内置 `_array.prajna`）
- 张量：`Tensor<Type, Dim>`（二维/三维等，见 `builtin_packages/tensor.prajna`）

## 4. 与数组/张量的结合

- 数组：
```prajna
var a: Array<i64, 4> = [1,2,3,4];
a[2].PrintLine();
```
- 张量（主机侧）：
```prajna
var A = Tensor<f32, 2>::Create([2,3]);
A[0,1] = 1.0f32;
```
- GPU 张量（参考 GPU 教程与 `nvgpu/amdgpu`）：
```prajna
var G = A.ToGpu();
var H = G.ToHost();
```

说明：`Array<Type, Length_>` 与 `Tensor<Type, Dim>` 都通过“类型+编译期常量”的模板组合表达数据形状与存储细节。

## 5. 为“泛型类型的实例”实现接口

你可以为“所有匹配模式的泛型类型实例”实现某个接口，这在算法抽象中非常常见。

示例：为 `Array<Type, Length_>`、`DynamicArray<ValueType>` 等实现 `Sortable`（插入排序），见 `builtin_packages/sortable.prajna` 与 `sort.prajna` 的思路：

```prajna
interface Sortable { func Sort(); func SortReverse(); }

template <Type, Length_>
implement Sortable for Array<Type, Length_> {
    func Sort() { /* ...插入排序... */ }
    func SortReverse() { /* ...倒序插入排序... */ }
}
```

意义：
- “对任意元素类型、任意长度”的数组都获得排序能力
- 接口 + 模板让“算法”和“数据结构”可以灵活组合

## 6. 类型别名与可读性

当模板参数较长时，使用 `as` 起别名提升可读性：

```prajna
use ::gpu::Tensor<f32, 2> as GpuMatrixf32;

func Main(){
    var A = GpuMatrixf32::Create([64, 64]);
}
```

## 7. 常见问题与修复

- 未显式写类型实参导致歧义
  - 现象：编译器无法推断或推断错误
  - 修复：显式写出：`Swap<i64>(&x, &y)`
- 在模板常量参数处使用了运行期变量
  - 现象：报“期望编译期常量”
  - 修复：把形状/长度作为模板参数或使用运行时容器（如 `DynamicArray`）
- 为泛型实现接口时遗漏模板参数
  - 现象：实现不生效或匹配不到类型
  - 修复：在 `implement` 与类型位点都带上相同模板参数

## 8. 练习

1) 实现 `template <T> struct Pair{first:T; second:T;}`，补充 `Swap()` 方法交换两项，并在 `Main` 中对 `i64` 与 `String` 验证。
2) 写 `template <T, N> func Sum(a: Array<T, N>)->T`，返回定长数组元素之和（从 `0` 初值累加）。
3) 参考 `sort.prajna` 的思路，为 `DynamicArray<T>` 实现 `Sortable` 接口的 `SortReverse()`。

——

