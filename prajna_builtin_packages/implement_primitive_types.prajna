
@intrinsic("llvm.sin.f32")
func sin_f32(v: f32)->f32;

implement bool {
    @instruction("ICmp", "ICMP_EQ")
    func __equal__(rhs : bool)->bool;

    @instruction("ICmp", "ICMP_NE")
    func __not_equal__(rhs : bool)->bool;

    @instruction("BinaryOperator", "And")
    func __and__(rhs: bool)->bool;

    @instruction("BinaryOperator", "Or")
    func __or__(rhs: bool)->bool;

    @instruction("BinaryOperator", "Xor")
    func __xor__(rhs: bool)->bool;

    func __not__()->bool{
        return this.__xor__(true);
    }
}

implement char {
    @instruction("ICmp", "ICMP_EQ")
    func __equal__(rhs : char)->bool;

    @instruction("ICmp", "ICMP_NE")
    func __not_equal__(rhs : char)->bool;

    @instruction("CastInst", "SExt", "i64")
    func toi64()->i64;
}

implement i8 {
    @instruction("ICmp", "ICMP_EQ")
    func __equal__(rhs : i8)->bool;

    @instruction("ICmp", "ICMP_NE")
    func __not_equal__(rhs : i8)->bool;

    @instruction("ICmp", "ICMP_SGT")
    func __greater__(rhs : i8)->bool;

    @instruction("ICmp", "ICMP_SLT")
    func __less__(rhs : i8)->bool;

    @instruction("ICmp", "ICMP_SGE")
    func __greater_or_equal__(rhs : i8)->bool;

    @instruction("ICmp", "ICMP_SLE")
    func __less_or_equal__(rhs : i8)->bool;

    @instruction("BinaryOperator", "Add")
    func __add__(rhs: i8)->i8;

    @instruction("BinaryOperator", "Sub")
    func __sub__(rhs: i8)->i8;

    @instruction("BinaryOperator", "Mul")
    func __multiply__(rhs: i8)->i8;

    @instruction("BinaryOperator", "SDiv")
    func __divide__(rhs: i8)->i8;

    @instruction("BinaryOperator", "SRem")
    func __remain__(rhs: i8)->i8;

    func __unary_sub__()->i8{
        return 0i8.__sub__(this);
    }

    @instruction("CastInst", "SExt", "i64")
    func toi64()->i64;

    @instruction("CastInst", "SIToFP", "f32")
    func tof32()->f32;

    // func tochar()->char{
    //     return &this
    // }
}

implement i16 {
    @instruction("ICmp", "ICMP_EQ")
    func __equal__(rhs : i16)->bool;

    @instruction("ICmp", "ICMP_NE")
    func __not_equal__(rhs : i16)->bool;

    @instruction("ICmp", "ICMP_SGT")
    func __greater__(rhs : i16)->bool;

    @instruction("ICmp", "ICMP_SLT")
    func __less__(rhs : i16)->bool;

    @instruction("ICmp", "ICMP_SGE")
    func __greater_or_equal__(rhs : i16)->bool;

    @instruction("ICmp", "ICMP_SLE")
    func __less_or_equal__(rhs : i16)->bool;

    @instruction("BinaryOperator", "Add")
    func __add__(rhs: i16)->i16;

    @instruction("BinaryOperator", "Sub")
    func __sub__(rhs: i16)->i16;

    @instruction("BinaryOperator", "Mul")
    func __multiply__(rhs: i16)->i16;

    @instruction("BinaryOperator", "SDiv")
    func __divide__(rhs: i16)->i16;

    @instruction("BinaryOperator", "SRem")
    func __remain__(rhs: i16)->i16;

    func __unary_sub__()->i16{
        return 0i16.__sub__(this);
    }

    @instruction("CastInst", "SExt", "i64")
    func toi64()->i64;

    @instruction("CastInst", "SIToFP", "f32")
    func tof32()->f32;

    @instruction("CastInst", "Trunc", "char")
    func tochar()->char;
}

implement i32 {
    @instruction("ICmp", "ICMP_EQ")
    func __equal__(rhs : i32)->bool;

    @instruction("ICmp", "ICMP_NE")
    func __not_equal__(rhs : i32)->bool;

    @instruction("ICmp", "ICMP_SGT")
    func __greater__(rhs : i32)->bool;

    @instruction("ICmp", "ICMP_SLT")
    func __less__(rhs : i32)->bool;

    @instruction("ICmp", "ICMP_SGE")
    func __greater_or_equal__(rhs : i32)->bool;

    @instruction("ICmp", "ICMP_SLE")
    func __less_or_equal__(rhs : i32)->bool;

    @instruction("BinaryOperator", "Add")
    func __add__(rhs: i32)->i32;

    @instruction("BinaryOperator", "Sub")
    func __sub__(rhs: i32)->i32;

    @instruction("BinaryOperator", "Mul")
    func __multiply__(rhs: i32)->i32;

    @instruction("BinaryOperator", "SDiv")
    func __divide__(rhs: i32)->i32;

    @instruction("BinaryOperator", "SRem")
    func __remain__(rhs: i32)->i32;

    func __unary_sub__()->i32{
        return 0i32.__sub__(this);
    }

    @instruction("CastInst", "SExt", "i64")
    func toi64()->i64;

    @instruction("CastInst", "SIToFP", "f32")
    func tof32()->f32;

    @instruction("CastInst", "Trunc", "char")
    func tochar()->char;

    // @static one()->i32{
    //     return 132;
    // }
}

implement i64 {
    @instruction("ICmp", "ICMP_EQ")
    func __equal__(rhs : i64)->bool;

    @instruction("ICmp", "ICMP_NE")
    func __not_equal__(rhs : i64)->bool;

    @instruction("ICmp", "ICMP_SGT")
    func __greater__(rhs : i64)->bool;

    @instruction("ICmp", "ICMP_SLT")
    func __less__(rhs : i64)->bool;

    @instruction("ICmp", "ICMP_SGE")
    func __greater_or_equal__(rhs : i64)->bool;

    @instruction("ICmp", "ICMP_SLE")
    func __less_or_equal__(rhs : i64)->bool;

    @instruction("BinaryOperator", "Add")
    func __add__(rhs: i64)->i64;

    @instruction("BinaryOperator", "Sub")
    func __sub__(rhs: i64)->i64;

    @instruction("BinaryOperator", "Mul")
    func __multiply__(rhs: i64)->i64;

    @instruction("BinaryOperator", "SDiv")
    func __divide__(rhs: i64)->i64;

    @instruction("BinaryOperator", "SRem")
    func __remain__(rhs: i64)->i64;

    func __unary_sub__()->i64{
        return 0i64.__sub__(this);
    }

    @instruction("CastInst", "SIToFP", "f32")
    func tof32()->f32;

    @instruction("CastInst", "Trunc", "i32")
    func toi32()->i32;

    @instruction("CastInst", "Trunc", "u32")
    func tou32()->u32;

    @instruction("CastInst", "Trunc", "char")
    func tochar()->char;

    @static
    func zero()->i64{
        return 0i64;
    }

    @static
    func one()->i64{
        return 1i64;
    }
}

implement u32 {
    @instruction("ICmp", "ICMP_EQ")
    func __equal__(rhs : u32)->bool;

    @instruction("ICmp", "ICMP_NE")
    func __not_equal__(rhs : u32)->bool;

    @instruction("ICmp", "ICMP_SGT")
    func __greater__(rhs : u32)->bool;

    @instruction("ICmp", "ICMP_SLT")
    func __less__(rhs : u32)->bool;

    @instruction("ICmp", "ICMP_SGE")
    func __greater_or_equal__(rhs : u32)->bool;

    @instruction("ICmp", "ICMP_SLE")
    func __less_or_equal__(rhs : u32)->bool;

    @instruction("BinaryOperator", "Add")
    func __add__(rhs: u32)->u32;

    @instruction("BinaryOperator", "Sub")
    func __sub__(rhs: u32)->u32;

    @instruction("BinaryOperator", "Mul")
    func __multiply__(rhs: u32)->u32;

    @instruction("BinaryOperator", "UDiv")
    func __divide__(rhs: u32)->u32;

    @instruction("BinaryOperator", "URem")
    func __remain__(rhs: u32)->u32;

    func __unary_add__()->u32{
        return this;
    }

    func __unary_sub__()->u32{
        return 0u32.__sub__(this);
    }

    @instruction("CastInst", "ZExt", "i64")
    func toi64()->i64;

    @instruction("CastInst", "UIToFP", "f32")
    func tof32()->f32;

    @instruction("CastInst", "Trunc", "char")
    func tochar()->char;
}

implement f32 {
    @instruction("FCmp", "FCMP_OEQ")
    func __equal__(rhs : f32)->bool;

    @instruction("FCmp", "FCMP_ONE")
    func __not_equal__(rhs : f32)->bool;

    @instruction("FCmp", "FCMP_OGT")
    func __greater__(rhs : f32)->bool;

    @instruction("FCmp", "FCMP_OLT")
    func __less__(rhs : f32)->bool;

    @instruction("FCmp", "FCMP_OGE")
    func __greater_or_equal__(rhs : f32)->bool;

    @instruction("FCmp", "FCMP_OLE")
    func __less_or_equal__(rhs : f32)->bool;

    @instruction("BinaryOperator", "FAdd")
    func __add__(rhs: f32)->f32;

    @instruction("BinaryOperator", "FSub")
    func __sub__(rhs: f32)->f32;

    @instruction("BinaryOperator", "FMul")
    func __multiply__(rhs: f32)->f32;

    @instruction("BinaryOperator", "FDiv")
    func __divide__(rhs: f32)->f32;

    @instruction("BinaryOperator", "FRem")
    func __remain__(rhs: f32)->f32;

    func __unary_sub__()->f32{
        return 0.0f32.__sub__(this);
    }

    @instruction("CastInst", "FPToSI", "i64")
    func toi64()->i64;

    func sin()->f32{
        return sin_f32(this);
    }

    @static
    func zero()->f32{
        return 0.0;
    }

    @static
    func one()->f32{
        return 1.0;
    }
}

export sin_f32;
