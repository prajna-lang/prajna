# 变量与类型系统

本篇面向第一次使用 Prajna 的同学，带你快速掌握“如何声明变量、如何选择和识别类型、何时需要显式转换、常见坑怎么避免”。读完你将能独立写出没有类型问题的基础程序。

你将学到：
- 如何声明/初始化变量，何时需要写类型
- Prajna 的强/静态类型规则，以及字面量后缀的用法
- 布尔、比较、字符与字符串的基本使用
- 显式转换（Cast/cast/bit_cast）的差别与使用时机
- 常见报错如何快速修好

提示：文中的示例都可以在 REPL 里一步步跟着敲（`prajna repl`），或写到一个 `.prajna` 文件用 `prajna exe` 运行。

## 1. 声明与初始化

- 使用 `var` 声明变量；可以写上类型，也可以让编译器从初始值“推断”出来。

```prajna
// 显式写类型（推荐初学时多这样写）
var a: i64;
var pi: f32 = 3.1415f32;

// 依赖推断（通过初始值的后缀推断类型）
var b = 10i64;   // 推断为 i64
```

要点：
- 必须先 `var`，再使用该变量
- 赋值/运算时，两边类型必须一致（Prajna 是强类型，不做隐式转换）

## 2. 字面量与类型后缀（非常重要）

给数字加“类型后缀”，编译器才能准确知道它是什么类型：
- 整数：`1i8 / 2i16 / 3i32 / 4i64 / 5i128`
- 无符号：`1u8 / 1u16 / 1u32 / 1u64 / 1u128`
- 浮点：`3.14f16 / 3.14f32 / 3.14f64`

示例：
```prajna
var x = 42i64;   // i64
var y = 2.0f32;  // f32
```

为什么要加后缀？因为 Prajna 不会自动把 `i64` 变 `f32`，也不会把“看起来像整型”的字面量自动套到你期望的类型里。后缀能让“类型”一眼明白，减少出错。

## 3. 强/静态类型：不做隐式转换

- 静态：类型在编译期确定
- 强类型：不同类型不能直接混用，必须显式转换

错误示例（会报错）：
```prajna
var i = 1i64;
var f = 2.0f32;
// i + f // 类型不一致
```
修正方法：把其中一个显式转换到另一个类型。
```prajna
(i.Cast<f32>() + f).PrintLine();
```

## 4. 显式转换：Cast、cast 与 bit_cast

- `.Cast<T>()`：最常用、最安全的值转换（如把 `i64` 转 `f32`）
- `cast<From, To>(value)`：模板形式的值转换，和 `.Cast<T>()` 等价
- `bit_cast<From, To>(value)`：按位“重解释”为另一个类型，要求内存布局/大小兼容（慎用）

示例：
```prajna
var a = 1i64;
var b: f32 = a.Cast<f32>();         // 值转换
var u: u64 = cast<i64, u64>(a);     // 模板写法
// var bad = bit_cast<i64, f32>(a); // 不要随意用 bit_cast，除非你清楚在做什么
```

## 5. 布尔与比较

- 类型：`bool`
- 比较：`==`, `!=`, `<`, `>`, `<=`, `>=`
- 逻辑：`&&`, `||`, `!`

示例：
```prajna
var ok: bool = (3i64 + 2i64) == 5i64;
ok.PrintLine(); // true
```

## 6. 字符与字符串（容易混）

- 字符：单引号，类型是 `char`，如 `'A'`
- 字符串：双引号，类型是 `String`，如 `"Hello"`

示例：
```prajna
var ch: char = 'Z';
var s: String = "Hi";
s.PrintLine();  // Hi
```

注意：`char` 和 `String` 不是一回事，不能直接混用；需要根据语义选择正确的类型。

## 7. 常见基础类型速览

- 有符号整数：`i8/i16/i32/i64/i128`
- 无符号整数：`u8/u16/u32/u64/u128`
- 浮点：`f16/f32/f64`
- 其他：`bool`, `char`, `void`, `undef`
- 复合类型（后续章节）：`Array<T, N>`、`DynamicArray<T>`、`String`、`Ptr<T>`、`Tensor<T,N>` 等

## 8. 综合示例：把整型参与浮点计算

目标：把循环计数（`i64`）换算为秒（`f32`）。
```prajna
func Main(){
    var frames = 120i64;     // 120 帧
    var fps    = 60.0f32;    // 60 帧/秒

    // 错误：frames / fps // 类型不一致
    var seconds = frames.Cast<f32>() / fps; // 2.0f32
    seconds.PrintLine();
}
```

## 9. 常见报错与快速修好

- “类型不匹配/不能从 X 赋值给 Y”
  - 检查两边类型是否一致；用 `.Cast<T>()` 统一
  - 给数字字面量加后缀：如 `10i64`、`3.0f32`
- “使用了未声明的变量”
  - 确保先 `var` 再用；检查作用域
- 字符 vs 字符串
  - `'a'` 是 `char`，`"a"` 是 `String`，选择正确的类型

## 10. 练习（建议在 REPL 完成）

1) 声明一个 `i64` 的变量 `count`，值为 `3`，声明一个 `f32` 的变量 `step`，值为 `0.5`，计算 `count * step`（结果应是 `1.5`）。要求不报类型错误并正确打印。
2) 写一个函数 `IsUpper(ch: char)->bool`，当 `ch` 在 `'A'..'Z'` 之间返回 `true`，否则 `false`；在 `Main` 中测试 `'A'`、`'z'`。

——
到这里，你已经掌握了 Prajna 的变量与类型基础。
