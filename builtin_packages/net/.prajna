use _c;

// Basic IPv4 address structure
struct Ipv4Addr {
    octets: array<u8, 4>;
}

implement Ipv4Addr {
    @static
    func Create(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {
        var addr: Ipv4Addr;
        addr.octets[0] = a;
        addr.octets[1] = b;
        addr.octets[2] = c;
        addr.octets[3] = d;
        return addr;
    }
    
    @static
    func Localhost() -> Ipv4Addr {
        return Ipv4Addr::Create(127u8, 0u8, 0u8, 1u8);
    }
    
    func ToString() -> String {
        var result = "";
        result = result + this.octets[0].ToString();
        result = result + ".";
        result = result + this.octets[1].ToString();
        result = result + ".";
        result = result + this.octets[2].ToString();
        result = result + ".";
        result = result + this.octets[3].ToString();
        return result;
    }
}

// Network constants
func GetAfInet() -> i32 {
    return 2i32; // AF_INET
}

func GetSockStream() -> i32 {
    return 1i32; // SOCK_STREAM
}

func GetSockDgram() -> i32 {
    return 2i32; // SOCK_DGRAM
}

// Basic socket functions
func CreateSocket(domain: i32, socket_type: i32, protocol: i32) -> i32 {
    return _c::socket(domain, socket_type, protocol);
}

func CloseSocket(sockfd: i32) -> i32 {
    return _c::close(sockfd);
}

func ListenSocket(sockfd: i32, backlog: i32) -> i32 {
    return _c::listen(sockfd, backlog);
}

func ReceiveData(sockfd: i32, buf: ptr<u8>, len: i64, flags: i32) -> i64 {
    return _c::recv(sockfd, buf, len, flags);
}

func SendData(sockfd: i32, buf: ptr<u8>, len: i64, flags: i32) -> i64 {
    return _c::send(sockfd, buf, len, flags);
}

// Network byte order conversion
func HostToNetworkShort(hostshort: u16) -> u16 {
    return _c::htons(hostshort);
}

func NetworkToHostShort(netshort: u16) -> u16 {
    return _c::ntohs(netshort);
}

// Helper functions for socket address handling
func CreateSocketAddrIn(ip_a: u8, ip_b: u8, ip_c: u8, ip_d: u8, port: u16) -> array<u8, 16> {
    var addr_buffer: array<u8, 16>;
    
    // Set AF_INET (2 in little endian)
    addr_buffer[0] = 2u8;
    addr_buffer[1] = 0u8;
    
    // Set port in network byte order
    var port_network = HostToNetworkShort(port);
    var port_low = cast<u16, u8>(port_network % 256u16);
    var port_high = cast<u16, u8>(port_network / 256u16);
    addr_buffer[2] = port_low;
    addr_buffer[3] = port_high;
    
    // Set IP address (already in correct byte order for IPv4)
    addr_buffer[4] = ip_a;
    addr_buffer[5] = ip_b;
    addr_buffer[6] = ip_c;
    addr_buffer[7] = ip_d;
    
    // Set sin_zero to all zeros
    addr_buffer[8] = 0u8;
    addr_buffer[9] = 0u8;
    addr_buffer[10] = 0u8;
    addr_buffer[11] = 0u8;
    addr_buffer[12] = 0u8;
    addr_buffer[13] = 0u8;
    addr_buffer[14] = 0u8;
    addr_buffer[15] = 0u8;
    
    return addr_buffer;
}

func ConnectToAddress(sockfd: i32, ip_a: u8, ip_b: u8, ip_c: u8, ip_d: u8, port: u16) -> i32 {
    var addr_buffer = CreateSocketAddrIn(ip_a, ip_b, ip_c, ip_d, port);
    var addr_ptr = &addr_buffer[0];
    
    return _c::connect_u8(sockfd, addr_ptr, 16u32);
}

func BindToAddress(sockfd: i32, ip_a: u8, ip_b: u8, ip_c: u8, ip_d: u8, port: u16) -> i32 {
    var addr_buffer = CreateSocketAddrIn(ip_a, ip_b, ip_c, ip_d, port);
    var addr_ptr = &addr_buffer[0];

    return _c::bind_u8(sockfd, addr_ptr, 16u32);
}

func AcceptConnection(sockfd: i32, addr_buffer: ptr<u8>, addrlen: ptr<u32>) -> i32 {
    return _c::accept_u8(sockfd, addr_buffer, addrlen);
}