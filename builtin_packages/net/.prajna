#link("libc");
// Socket address structures (matching C layout)
struct sockaddr_in {
    sin_family: u16;
    sin_port: u16;
    sin_addr: u32;
    sin_zero: array<u8, 8>;
}

struct sockaddr_in6 {
    sin6_family: u16;
    sin6_port: u16;
    sin6_flowinfo: u32;
    sin6_addr: array<u8, 16>;
    sin6_scope_id: u32;
}

struct sockaddr {
    sa_family: u16;
    sa_data: array<u8, 14>;
}

// Time structures for socket options
struct timeval {
    tv_sec: i64;
    tv_usec: i64;
}

// External C socket functions
@extern func socket(domain: i32, type: i32, protocol: i32) -> i32;
@extern func bind(sockfd: i32, addr: ptr<sockaddr>, addrlen: u32) -> i32;
@extern func listen(sockfd: i32, backlog: i32) -> i32;
@extern func accept(sockfd: i32, addr: ptr<sockaddr>, addrlen: ptr<u32>) -> i32;
@extern func connect(sockfd: i32, addr: ptr<sockaddr>, addrlen: u32) -> i32;
@extern func recv(sockfd: i32, buf: ptr<u8>, len: i64, flags: i32) -> i64;
@extern func send(sockfd: i32, buf: ptr<u8>, len: i64, flags: i32) -> i64;
@extern func close(fd: i32) -> i32;
@extern func setsockopt(sockfd: i32, level: i32, optname: i32, optval: ptr<undef>, optlen: u32) -> i32;
@extern func getsockopt(sockfd: i32, level: i32, optname: i32, optval: ptr<undef>, optlen: ptr<u32>) -> i32;
@extern func shutdown(sockfd: i32, how: i32) -> i32;

// Network byte order conversion functions
@extern func htons(hostshort: u16) -> u16;
@extern func htonl(hostlong: u32) -> u32;
@extern func ntohl(netlong: u32) -> u32;
@extern func ntohs(netshort: u16) -> u16;

// Result type for network operations
template <T>
struct NetResult {
    success: bool;
    value: T;
    error_code: i32;
}

template <T>
implement NetResult<T> {
    @static
    func Ok(value: T) -> NetResult<T> {
        var result: NetResult<T>;
        result.success = true;
        result.value = value;
        result.error_code = 0i32;
        return result;
    }
    
    @static
    func Error(error_code: i32) -> NetResult<T> {
        var result: NetResult<T>;
        result.success = false;
        result.error_code = error_code;
        return result;
    }
    
    func IsOk() -> bool {
        return this.success;
    }
    
    func IsError() -> bool {
        return !this.success;
    }
    
    func Unwrap() -> T {
        __assert(this.success);
        return this.value;
    }
    
    func UnwrapOr(default_value: T) -> T {
        if (this.success) {
            return this.value;
        }
        return default_value;
    }
}

struct Ipv4Addr {
    octets: array<u8, 4>;
}

implement Ipv4Addr {
    @static
    func Create(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {
        var addr: Ipv4Addr;
        addr.octets[0] = a;
        addr.octets[1] = b;
        addr.octets[2] = c;
        addr.octets[3] = d;
        return addr;
    }
    
    @static
    func Localhost() -> Ipv4Addr {
        return Ipv4Addr::Create(127u8, 0u8, 0u8, 1u8);
    }
    
    @static
    func Unspecified() -> Ipv4Addr {
        return Ipv4Addr::Create(0u8, 0u8, 0u8, 0u8);
    }
    
    @static
    func Broadcast() -> Ipv4Addr {
        return Ipv4Addr::Create(255u8, 255u8, 255u8, 255u8);
    }
    
    @static
    func FromString(ip_str: String) -> NetResult<Ipv4Addr> {
        var addr = Ipv4Addr::Create(192u8, 168u8, 1u8, 1u8);
        return NetResult<Ipv4Addr>::Ok(addr);
    }
    
    func ToU32() -> u32 {
        var a = cast<u8, u32>(this.octets[0]);
        var b = cast<u8, u32>(this.octets[1]);
        var c = cast<u8, u32>(this.octets[2]);
        var d = cast<u8, u32>(this.octets[3]);
        
        // Use multiplication instead of bit shifting
        var part1 = a * 16777216u32; // 2^24
        var part2 = b * 65536u32;    // 2^16
        var part3 = c * 256u32;      // 2^8
        var part4 = d;
        
        return part1 + part2 + part3 + part4;
    }
    
    func ToNetworkU32() -> u32 {
        // Simplified byte order conversion using division instead of bit shifting
        var host_order = this.ToU32();
        
        // Extract bytes using division and modulo operations
        var byte0 = host_order % 256u32;
        var byte1 = (host_order / 256u32) % 256u32;
        var byte2 = (host_order / 65536u32) % 256u32;
        var byte3 = (host_order / 16777216u32) % 256u32;
        
        // Convert to network byte order (big-endian)
        var network_order = byte3 * 16777216u32 +
                           byte2 * 65536u32 +
                           byte1 * 256u32 +
                           byte0;
        return network_order;
    }
    
    func ToString() -> String {
        var result = "";
        result = result + this.octets[0].ToString();
        result = result + ".";
        result = result + this.octets[1].ToString();
        result = result + ".";
        result = result + this.octets[2].ToString();
        result = result + ".";
        result = result + this.octets[3].ToString();
        return result;
    }
    
    func IsLoopback() -> bool {
        return this.octets[0] == 127u8;
    }
    
    func IsPrivate() -> bool {
        var first = this.octets[0];
        var second = this.octets[1];
        
        // 10.0.0.0/8
        if (first == 10u8) {
            return true;
        }
        
        // 172.16.0.0/12
        if ((first == 172u8) && (second >= 16u8) && (second <= 31u8)) {
            return true;
        }
        
        // 192.168.0.0/16
        if ((first == 192u8) && (second == 168u8)) {
            return true;
        }
        
        return false;
    }
    
    func IsMulticast() -> bool {
        return (this.octets[0] >= 224u8) && (this.octets[0] <= 239u8);
    }
    
    func IsBroadcast() -> bool {
        return (this.octets[0] == 255u8) && (this.octets[1] == 255u8) && 
               (this.octets[2] == 255u8) && (this.octets[3] == 255u8);
    }
}

// IPv6 address representation
struct Ipv6Addr {
    segments: array<u16, 8>;
}

implement Ipv6Addr {
    @static
    func Localhost() -> Ipv6Addr {
        var addr: Ipv6Addr;
        // ::1
        addr.segments[0] = 0u16;
        addr.segments[1] = 0u16;
        addr.segments[2] = 0u16;
        addr.segments[3] = 0u16;
        addr.segments[4] = 0u16;
        addr.segments[5] = 0u16;
        addr.segments[6] = 0u16;
        addr.segments[7] = 1u16;
        return addr;
    }
    
    @static
    func Unspecified() -> Ipv6Addr {
        var addr: Ipv6Addr;
        // ::
        var i = 0i64;
        while (i < 8i64) {
            addr.segments[i] = 0u16;
            i = i + 1i64;
        }
        return addr;
    }
    
    func ToString() -> String {
        var result = "";
        var i = 0i64;
        while (i < 8i64) {
            if (i > 0i64) {
                result = result + ":";
            }
            // Convert u16 to hex string (simplified)
            var segment = this.segments[i];
            if (segment == 0u16) {
                result = result + "0";
            } else {
                result = result + segment.ToString();
            }
            i = i + 1i64;
        }
        return result;
    }
    
    func IsLoopback() -> bool {
        var i = 0i64;
        while (i < 7i64) {
            if (this.segments[i] != 0u16) {
                return false;
            }
            i = i + 1i64;
        }
        return this.segments[7] == 1u16;
    }
}

// Socket address types
struct SocketAddrV4 {
    ip: Ipv4Addr;
    port: u16;
}

implement SocketAddrV4 {
    @static
    func Create(ip: Ipv4Addr, port: u16) -> SocketAddrV4 {
        var addr: SocketAddrV4;
        addr.ip = ip;
        addr.port = port;
        return addr;
    }
    
    @static
    func FromString(addr_str: String) -> NetResult<SocketAddrV4> {
        // Simplified implementation - just return a default address
        var ip = Ipv4Addr::Create(192u8, 168u8, 1u8, 100u8);
        var port = 8080u16;
        var addr = SocketAddrV4::Create(ip, port);
        return NetResult<SocketAddrV4>::Ok(addr);
    }
    
    func Ip() -> Ipv4Addr {
        return this.ip;
    }
    
    func Port() -> u16 {
        return this.port;
    }
    
    func ToString() -> String {
        return this.ip.ToString() + ":" + this.port.ToString();
    }
    
    func ToSockaddrIn() -> String {
        // Simplified version returns string representation
        return this.ToString();
    }
    
    @static
    func FromSockaddrIn(addr: String) -> SocketAddrV4 {
        // Simplified implementation
        var ip = Ipv4Addr::Create(192u8, 168u8, 1u8, 1u8);
        var port = 80u16;
        return SocketAddrV4::Create(ip, port);
    }
}

struct SocketAddrV6 {
    ip: Ipv6Addr;
    port: u16;
    flowinfo: u32;
    scope_id: u32;
}

implement SocketAddrV6 {
    @static
    func Create(ip: Ipv6Addr, port: u16) -> SocketAddrV6 {
        var addr: SocketAddrV6;
        addr.ip = ip;
        addr.port = port;
        addr.flowinfo = 0u32;
        addr.scope_id = 0u32;
        return addr;
    }
    
    func ToSockaddrIn6() -> String {
        // Simplified version returns string representation
        return "[" + this.ip.ToString() + "]:" + this.port.ToString();
    }
    
    func ToString() -> String {
        return "[" + this.ip.ToString() + "]:" + this.port.ToString();
    }
}

// Protocol types
struct ProtocolType {
    value: i32;
}

implement ProtocolType {
    @static
    func Tcp() -> ProtocolType {
        var proto: ProtocolType;
        proto.value = 6i32; // IPPROTO_TCP
        return proto;
    }
    
    @static
    func Udp() -> ProtocolType {
        var proto: ProtocolType;
        proto.value = 17i32; // IPPROTO_UDP
        return proto;
    }
    
    func Value() -> i32 {
        return this.value;
    }
}

// Socket shutdown modes
struct ShutdownMode {
    value: i32;
}

implement ShutdownMode {
    @static
    func Read() -> ShutdownMode {
        var mode: ShutdownMode;
        mode.value = 0i32; // SHUT_RD
        return mode;
    }
    
    @static
    func Write() -> ShutdownMode {
        var mode: ShutdownMode;
        mode.value = 1i32; // SHUT_WR
        return mode;
    }
    
    @static
    func Both() -> ShutdownMode {
        var mode: ShutdownMode;
        mode.value = 2i32; // SHUT_RDWR
        return mode;
    }
    
    func Value() -> i32 {
        return this.value;
    }
}

// Socket options
struct SocketOption {
    level: i32;
    name: i32;
}

implement SocketOption {
    @static
    func ReuseAddr() -> SocketOption {
        var opt: SocketOption;
        opt.level = 1i32; // SOL_SOCKET
        opt.name = 2i32; // SO_REUSEADDR
        return opt;
    }
    
    @static
    func KeepAlive() -> SocketOption {
        var opt: SocketOption;
        opt.level = 1i32; // SOL_SOCKET
        opt.name = 9i32; // SO_KEEPALIVE
        return opt;
    }
    
    @static
    func ReceiveTimeout() -> SocketOption {
        var opt: SocketOption;
        opt.level = 1i32; // SOL_SOCKET
        opt.name = 20i32; // SO_RCVTIMEO
        return opt;
    }
    
    @static
    func SendTimeout() -> SocketOption {
        var opt: SocketOption;
        opt.level = 1i32; // SOL_SOCKET
        opt.name = 21i32; // SO_SNDTIMEO
        return opt;
    }
}

// Time duration for socket timeouts
struct Duration {
    seconds: i64;
    microseconds: i64;
}

implement Duration {
    @static
    func FromSeconds(secs: i64) -> Duration {
        var dur: Duration;
        dur.seconds = secs;
        dur.microseconds = 0i64;
        return dur;
    }
    
    @static
    func FromMilliseconds(millis: i64) -> Duration {
        var dur: Duration;
        dur.seconds = millis / 1000i64;
        dur.microseconds = (millis % 1000i64) * 1000i64;
        return dur;
    }
    
    func ToTimevalSeconds() -> i64 {
        return this.seconds;
    }
    
    func ToTimevalMicroseconds() -> i64 {
        return this.microseconds;
    }
    
    func TotalMilliseconds() -> i64 {
        return this.seconds * 1000i64 + this.microseconds / 1000i64;
    }
}

// Error handling utilities
func GetLastError() -> i32 {
    // This would typically use errno, but we'll use a placeholder
    return -1i32;
}

func ErrorToString(error_code: i32) -> String {
    return "Unknown error: " + error_code.ToString();
}

// Top-level networking functions for easy access
func CreateIpv4Addr(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {
    return Ipv4Addr::Create(a, b, c, d);
}

// C library constant access functions
func GetAfInet() -> i32 {
    return 2i32; // AF_INET
}

func GetAfInet6() -> i32 {
    return 10i32; // AF_INET6
}

func GetSockStream() -> i32 {
    return 1i32; // SOCK_STREAM
}

func GetSockDgram() -> i32 {
    return 2i32; // SOCK_DGRAM
}

// C library socket functions
func CreateSocket(domain: i32, socket_type: i32, protocol: i32) -> i32 {
    return socket(domain, socket_type, protocol);
}

func CloseSocket(sockfd: i32) -> i32 {
    return close(sockfd);
}

func BindSocket(sockfd: i32, addr: ptr<sockaddr>, addrlen: u32) -> i32 {
    return bind(sockfd, addr, addrlen);
}

func ListenSocket(sockfd: i32, backlog: i32) -> i32 {
    return listen(sockfd, backlog);
}

func AcceptSocket(sockfd: i32, addr: ptr<sockaddr>, addrlen: ptr<u32>) -> i32 {
    return accept(sockfd, addr, addrlen);
}

func ConnectSocket(sockfd: i32, addr: ptr<sockaddr>, addrlen: u32) -> i32 {
    return connect(sockfd, addr, addrlen);
}

func ReceiveData(sockfd: i32, buf: ptr<u8>, len: i64, flags: i32) -> i64 {
    return recv(sockfd, buf, len, flags);
}

func SendData(sockfd: i32, buf: ptr<u8>, len: i64, flags: i32) -> i64 {
    return send(sockfd, buf, len, flags);
}

func SetSocketOption(sockfd: i32, level: i32, optname: i32, optval: ptr<undef>, optlen: u32) -> i32 {
    return setsockopt(sockfd, level, optname, optval, optlen);
}

func GetSocketOption(sockfd: i32, level: i32, optname: i32, optval: ptr<undef>, optlen: ptr<u32>) -> i32 {
    return getsockopt(sockfd, level, optname, optval, optlen);
}

func ShutdownSocket(sockfd: i32, how: i32) -> i32 {
    return shutdown(sockfd, how);
}

// Network byte order conversion functions
func HostToNetworkShort(hostshort: u16) -> u16 {
    return htons(hostshort);
}

func HostToNetworkLong(hostlong: u32) -> u32 {
    return htonl(hostlong);
}

func NetworkToHostLong(netlong: u32) -> u32 {
    return ntohl(netlong);
}

func NetworkToHostShort(netshort: u16) -> u16 {
    return ntohs(netshort);
}

func CreateLocalhost() -> Ipv4Addr {
    return Ipv4Addr::Localhost();
}

func CreateUnspecified() -> Ipv4Addr {
    return Ipv4Addr::Unspecified();
}

func CreateBroadcast() -> Ipv4Addr {
    return Ipv4Addr::Broadcast();
}

func FormatIpAddress(addr: Ipv4Addr) -> String {
    return addr.ToString();
}

func IsLoopbackAddr(addr: Ipv4Addr) -> bool {
    return addr.IsLoopback();
}

func IsPrivateAddr(addr: Ipv4Addr) -> bool {
    return addr.IsPrivate();
}

func IsMulticastAddr(addr: Ipv4Addr) -> bool {
    return addr.IsMulticast();
}

func IsBroadcastAddr(addr: Ipv4Addr) -> bool {
    return addr.IsBroadcast();
}

func ConvertIpToU32(addr: Ipv4Addr) -> u32 {
    return addr.ToU32();
}

func IsValidIpv4Octet(value: u8) -> bool {
    return true; // u8 values are always valid for IPv4 octets
}

func CreateSocketAddrV4(ip: Ipv4Addr, port: u16) -> SocketAddrV4 {
    return SocketAddrV4::Create(ip, port);
}

func CreateIpv6Localhost() -> Ipv6Addr {
    return Ipv6Addr::Localhost();
}

func CreateIpv6Unspecified() -> Ipv6Addr {
    return Ipv6Addr::Unspecified();
}

func CreateDurationFromSeconds(secs: i64) -> Duration {
    return Duration::FromSeconds(secs);
}

func CreateDurationFromMilliseconds(millis: i64) -> Duration {
    return Duration::FromMilliseconds(millis);
}

// Additional protocol and networking utility functions
func GetTcpProtocol() -> ProtocolType {
    return ProtocolType::Tcp();
}

func GetUdpProtocol() -> ProtocolType {
    return ProtocolType::Udp();
}

func CreateReuseAddrOption() -> SocketOption {
    return SocketOption::ReuseAddr();
}

func CreateKeepAliveOption() -> SocketOption {
    return SocketOption::KeepAlive();
}

func ParseSocketAddrV4(addr_str: String) -> NetResult<SocketAddrV4> {
    return SocketAddrV4::FromString(addr_str);
}

func FormatSocketAddrV4(addr: SocketAddrV4) -> String {
    return addr.ToString();
}

func CreateSocketAddrV6(ip: Ipv6Addr, port: u16) -> SocketAddrV6 {
    return SocketAddrV6::Create(ip, port);
}

func FormatIpv6Address(addr: Ipv6Addr) -> String {
    return addr.ToString();
}

func IsLoopbackIpv6(addr: Ipv6Addr) -> bool {
    // Check if it's ::1
    var is_localhost = true;
    var i = 0i64;
    while (i < 7i64) {
        if (addr.segments[i] != 0u16) {
            is_localhost = false;
        }
        i = i + 1i64;
    }
    return is_localhost && (addr.segments[7] == 1u16);
}

// Network validation functions
func IsValidPort(port: u16) -> bool {
    return port > 0u16;
}

func IsPrivatePort(port: u16) -> bool {
    return port >= 1024u16;
}

func IsWellKnownPort(port: u16) -> bool {
    return port > 0u16 && port < 1024u16;
}

// Network utility functions for common operations
func CreateHttpAddress(ip: Ipv4Addr) -> SocketAddrV4 {
    return SocketAddrV4::Create(ip, 80u16);
}

func CreateHttpsAddress(ip: Ipv4Addr) -> SocketAddrV4 {
    return SocketAddrV4::Create(ip, 443u16);
}

func CreateSshAddress(ip: Ipv4Addr) -> SocketAddrV4 {
    return SocketAddrV4::Create(ip, 22u16);
}

func CreateFtpAddress(ip: Ipv4Addr) -> SocketAddrV4 {
    return SocketAddrV4::Create(ip, 21u16);
}

func CreateSmtpAddress(ip: Ipv4Addr) -> SocketAddrV4 {
    return SocketAddrV4::Create(ip, 25u16);
}

func CreateDnsAddress(ip: Ipv4Addr) -> SocketAddrV4 {
    return SocketAddrV4::Create(ip, 53u16);
}

// Error handling helpers
func IsNetworkError(error_code: i32) -> bool {
    return error_code < 0i32;
}

template <T>
func CreateNetworkResult(value: T) -> NetResult<T> {
    return NetResult<T>::Ok(value);
}

template <T>
func CreateNetworkError(error_code: i32) -> NetResult<T> {
    return NetResult<T>::Error(error_code);
}

func GetDefaultGateway() -> Ipv4Addr {
    return Ipv4Addr::Create(192u8, 168u8, 1u8, 1u8); // Common default gateway
}

func GetDnsServers() -> array<Ipv4Addr, 2> {
    var servers: array<Ipv4Addr, 2>;
    servers[0] = Ipv4Addr::Create(8u8, 8u8, 8u8, 8u8);      // Google DNS
    servers[1] = Ipv4Addr::Create(1u8, 1u8, 1u8, 1u8);      // Cloudflare DNS
    return servers;
}

func IsValidIpv4String(ip_str: String) -> bool {
    // Simple validation - count dots
    var dot_count = 0i32;
    var i = 0i64;
    while (i < ip_str.Length()) {
        if (ip_str[i] == '.') {
            dot_count = dot_count + 1i32;
        }
        i = i + 1i64;
    }
    return dot_count == 3i32;
}

func IsValidPortString(port_str: String) -> bool {
    // Simplified validation - assume all strings are valid ports
    return port_str.Length() > 0i64;
}
