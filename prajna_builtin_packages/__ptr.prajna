
template <Type_>
struct ptr<Type_>{
    raw_ptr: Type_*;
}

template <Type_>
implement ptr<Type_>{
    @static
    func allocate(size: i64)->ptr<Type_>{
        var self: ptr<Type_>;
        self.raw_ptr =  cast<Type_ *>(malloc(size.__multiply__(sizeof(Type_))));
        bindings::registerReferenceCount(cast<undef*>(self.raw_ptr));
        bindings::incrementReferenceCount(cast<undef*>(self.raw_ptr));
        return self;
    }

    @static
    func new()->ptr<Type_>{
        var t = allocate(1);
        return t;
    }

    @static
    func null()->ptr<Type_>{
        var self: ptr<Type_>;
        self.raw_ptr = i64_to_rawptr<Type_>(0);
        return self;
    }

    func toi64()->i64{
        return rawptr_to_i64(this.raw_ptr);
    }

    // 因为内存计数是直接通过指针地址来记录的. 所以只要他们有相同的机制, 那么指针的传输, 转变不会导致错误.
    func toUndef()->ptr<undef>{
        var undef_ptr: ptr<undef>;
        undef_ptr.raw_ptr = cast<undef *>(this.raw_ptr);
        return undef_ptr;
    }

    @static
    func fromUndef(undef_ptr: ptr<undef>)->ptr<Type_>{
        var self: ptr<Type_>;
        self.raw_ptr = cast<Type_ *>(undef_ptr.raw_ptr);
        return self;
    }


    func isNull()->bool{
        return this.toi64() == 0;
    }

    func referenceCount()->i64 {
        return bindings::getReferenceCount(cast<undef*>(this.raw_ptr));
    }
}

// template <Type_>
// implement operator::LinearIndex<Type_> for ptr<Type_> {
//     func gets(index: i64)->Type_ {
//         return  this.raw_ptr[index];
//     }
//     func sets(index: i64, value: Type_) {
//         this.raw_ptr[index] = value;
//     }
// }

template <Type_>
@disable_dynamic_dispatch
implement reference_count::ReferenceCountable for ptr<Type_> {
    func initialize() {
        this.raw_ptr = i64_to_rawptr<Type_>(0);
        this.registerReferenceCount();
    }

    func registerReferenceCount() {
        bindings::registerReferenceCount(cast<undef*>(this.raw_ptr));
    }

    func incrementReferenceCount() {
        bindings::incrementReferenceCount(cast<undef*>(this.raw_ptr));
    }

    func decrementReferenceCount() {
        bindings::decrementReferenceCount(cast<undef*>(this.raw_ptr));
        if (bindings::getReferenceCount(cast<undef*>(this.raw_ptr)).__equal__(0)){
            if (!this.isNull()){
                bindings::free(cast<undef*>(this.raw_ptr));
                this.raw_ptr = i64_to_rawptr<Type_>(0);
            }
        }
    }
}

export ptr;
