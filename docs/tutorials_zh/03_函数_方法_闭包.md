# 函数、方法与闭包（给初学者）

本篇带你系统掌握 Prajna 的可执行单元：普通函数、结构体方法、静态方法与闭包（匿名函数），并补充高阶用法与常见坑的修复方式。

你将学到：
- 函数签名、返回值与“无返回值”函数
- 结构体方法与 `implement` 块、`this` 的使用
- `@static` 静态方法何时用、怎么用
- 闭包（匿名函数）语法、捕获规则、作为值传递
- 高阶函数：函数作为参数与返回值

建议边看边在 REPL 中尝试（`prajna repl`），或写到 `.prajna` 文件用 `prajna exe` 运行。

## 1. 普通函数

定义：函数是不隶属于任何实例的可重用代码块，无 `this`，形如 `func Name(params)->Return { ... }`，用于计算或组织流程。

- 基本形态：`func Name(params)->ReturnType { ... }`
- 无返回值时可省略 `-> Type`

```prajna
// 有返回值
func Add(a: i64, b: i64)->i64 {
    return a + b;
}

// 无返回值（过程函数）
func PrintSum(a: i64, b: i64) {
    (a + b).PrintLine();
}

func Main(){
    Add(2i64, 3i64).PrintLine();   // 5
    PrintSum(2i64, 3i64);          // 5
}
```

要点：
- 参数与返回值都是强/静态类型，调用时类型必须匹配（可用 `.Cast<T>()` 调整）

## 2. 结构体方法（面向数据的函数）

定义：方法绑定到某个类型（结构体），写在 `implement Type { ... }` 内，方法体用 `this` 访问当前实例字段。

使用 `implement Type { ... }` 给结构体增加方法；方法体内通过 `this` 访问当前实例。

```prajna
struct Point { x: i64; y: i64; }

implement Point {
    func Length2()->i64 {
        return this.x*this.x + this.y*this.y;
    }

    func Move(dx: i64, dy: i64) {
        this.x = this.x + dx;
        this.y = this.y + dy;
    }
}

func Main(){
    var p: Point;
    p.x = 3i64; p.y = 4i64;
    p.Length2().PrintLine(); // 25
    p.Move(1i64, -2i64);
    p.Length2().PrintLine(); //  (4,2) -> 20
}
```

## 3. 静态方法（构造/工厂/工具）

定义：静态方法与“类型”本身关联，用 `@static` 标注，无需实例即可调用；常用于工厂函数、常量创建、与实例无关的工具函数。

使用 `@static` 将方法与类型相关联、而非与实例相关：

```prajna
struct Pair { a: i64; b: i64; }

implement Pair {
    @static
    func Create(a: i64, b: i64)->Pair {
        var p: Pair; p.a = a; p.b = b; return p;
    }
}

func Main(){
    var p = Pair::Create(1i64, 2i64);
    (p.a + p.b).PrintLine();
}
```

## 4. 闭包（匿名函数）

定义：闭包是匿名的“函数值”，语法 `(params)->Ret { ... }` 或 `(){ ... }`，可自动捕获其使用到的外部变量；是一等公民，可赋值、传参、返回。

- 语法：`(params)->Ret { ... }` 或 `(){ ... }`（无参）
- 闭包会自动捕获其使用到的外围变量（示例见下）

```prajna
func Main(){
    // 最简单的闭包
    var hello = (){ "Hello".PrintLine(); };
    hello();

    // 有参闭包
    var add = (a: i64, b: i64)->i64 { return a + b; };
    add(2i64, 3i64).PrintLine();

    // 捕获外部变量
    var x = 100i64;
    var capture_add = (v: i64)->i64 { return v + x; };
    capture_add(10i64).PrintLine();
}
```

提示：闭包是“值”，可以赋给变量、作为参数传递、作为返回值返回。

## 5. 高阶函数：函数作参数/返回值

定义：高阶函数是“以函数为参数，或返回一个函数”的函数。结合闭包可表达强大抽象。

你可以编写“接收函数”的函数：

```prajna
// 接受一个一元函数并应用两次
func ApplyTwice(f: (i64)->i64, v: i64)->i64 {
    return f(f(v));
}

func Main(){
    var inc = (x: i64)->i64 { return x + 1i64; };
    ApplyTwice(inc, 10i64).PrintLine(); // 12
}
```

小技巧（此处的“内联”指在调用处直接写出匿名函数，而不是编译优化的 @inline）：
- 代码内联书写：把匿名函数直接写在实参位置，便于就近表达。
  ```prajna
  ApplyTwice((x: i64)->i64 { return x + 1i64; }, 10i64);
  ```
- 与具名变量对照：先赋给变量再传，便于复用或让调用处更简短。
  ```prajna
  var inc = (x: i64)->i64 { return x + 1i64; };
  ApplyTwice(inc, 10i64);
  ```
注意：这里的“内联”不是编译器的函数内联优化；若需建议编译器内联，请对小而高频的函数使用 `@inline` 标注。

## 6. 常见问题与修复

- 参数/返回类型不匹配
  - 使用 `.Cast<T>()` 或为字面量添加后缀（如 `1i64`、`2.0f32`）
- 闭包捕获值类型不一致
  - 统一捕获变量与参数的类型（需要时 `.Cast<T>()`）
- 将“方法”误写成“普通函数”
  - 需要访问 `this` 就把函数写在 `implement Type { ... }` 中

## 7. 练习

1) 为 `Point` 增加方法 `Dot(rhs: Point)->i64` 计算点积，并在 `Main` 中验证 `(1,2)·(3,4)=11`。
2) 写一个函数 `MapAddOne(f: (i64)->i64, v: i64)->i64`，要求在调用前先将 `v` 加一，再把结果交给 `f`，并在 `Main` 中使用闭包测试。

——

