# C 库绑定与动态链接（给初学者）

本篇讲清如何在 Prajna 中调用现有的 C 动态库函数：把库加载进来（动态链接）、声明要用的符号（函数/变量）、完成类型与字符串的互操作，并给出常见排错方法。

你将学到：
- 动态库放在哪里、程序如何找到它（不同系统的搜索路径）
- `#link("libname")` 的作用与多库加载
- 用 `@extern` 绑定 C 函数到 Prajna
- C 与 Prajna 的基础类型对应关系
- C 字符串与 Prajna `String` 互操作
- 例子与常见错误排查

## 1. 前置条件与库搜索路径

- 需要一个已编译好的动态库（例如 `libzmq.so`/`libzmq.dylib`/`libzmq.dll`）
- 程序如何找到库（至少满足其一）：
  - 把动态库放在系统搜索路径内
  - 或把库所在目录加入环境变量：
    - Windows：`PATH`
    - Linux：`LD_LIBRARY_PATH`
    - macOS：`DYLD_LIBRARY_PATH`
  - 或与可执行文件位于同一目录（具体取决于系统/加载器）

命名提示：
- Linux：通常以 `libXxx.so` 命名
- macOS：通常以 `libXxx.dylib` 命名
- Windows：通常以 `Xxx.dll` 命名

## 2. 加载库：`#link("libname")`

在源文件中写入：
```prajna
#link("libzmq")
```
含义：将名为 `libzmq` 的动态库加载到当前 JIT 引擎，并把其导出的符号加入可解析范围。可以写多次加载多个库：
```prajna
#link("libzmq")
#link("anotherlib")
```

注意：这里写的是“库名”，而不是文件全名；底层会按平台补全前后缀并搜索（前提是库在可搜索路径中）。

## 3. 绑定 C 函数：`@extern`

用 `@extern` 声明需要使用的 C 符号（函数/变量）。示例：
```prajna
@extern func zmq_errno()->i32;             // 无参，返回 i32
@extern func zmq_version(major: ptr<i32>, minor: ptr<i32>, patch: ptr<i32>);
```

使用时就像本地函数一样调用：
```prajna
func Main(){
    var major: i32; var minor: i32; var patch: i32;
    zmq_version(&major, &minor, &patch);
    major.Print(); ".".Print(); minor.Print(); ".".Print(); patch.PrintLine();
}
```

## 4. 常见 C ↔ Prajna 类型对应

- `int` → `i32`
- `long long` → `i64`
- `float` → `f32`
- `double` → `f64`
- `char*` → `ptr<char>`（C 字符串）
- `void*` → `ptr<undef>`（无具体类型的指针）
- `size_t` → 通常为 `i64`（在 64 位平台）；请以你的目标平台为准
- 结构体指针 → `ptr<MyStruct>`（按需在 Prajna 侧定义镜像结构体）

关键点：
- 函数签名必须“按 ABI 精确匹配”，否则会崩溃或得到错误结果
- 指针参数代表“可被修改”的输出/输入输出；要传入地址（`&var`）

## 5. 字符串互操作

- 从 C `char*` 转为 Prajna `String`：
```prajna
var s = String::__from_char_ptr(cstr_ptr);
s.PrintLine();
```
- 从 Prajna `String` 转为 C `char*`：
```prajna
var cptr = s.CStringRawPointer(); // 内部会在末尾补 '\0'
```

## 6. 最小可运行示例

以 ZeroMQ 里两个简单符号为例（需已安装该库且可被找到）：
```prajna
#link("libzmq")
@extern func zmq_errno()->i32;
@extern func zmq_strerror(errnum: i32)->ptr<char>;

func Main(){
    var err = zmq_errno();
    var msg = zmq_strerror(err);
    String::__from_char_ptr(msg).PrintLine();
}
```
如库不可用，可将示例改为你本机有的库与符号，例如一个自编译的 `mylib`：
```prajna
#link("mylib")
@extern func add_i64(a: i64, b: i64)->i64;

func Main(){
    add_i64(2i64, 40i64).PrintLine(); // 42
}
```

## 7. 常见错误与排查

- 找不到库（加载失败）
  - 检查库是否存在；把所在目录加入 `PATH/LD_LIBRARY_PATH/DYLD_LIBRARY_PATH`
  - 库名不对：去掉前缀 `lib` 与后缀 `.so/.dylib/.dll` 后再写入 `#link("...")`
- 找不到符号
  - 确认库确实导出了该函数（用 `nm/objdump/dumpbin` 检查）
  - 名字修饰/调用约定不一致：确保使用 C 接口导出（`extern "C"`）且签名匹配
- 调用崩溃/结果异常
  - 函数签名（参数与返回值）是否完全一致；指针是否有效；是否传对了地址
  - 32/64 位不一致；平台 ABI 不匹配
- 字符串乱码
  - 确保传入/返回的是以 `\0` 结尾的 C 字符串；注意编码（UTF-8/GBK 等）

## 8. 练习

1) 选择一个已安装库（或自编译动态库），绑定 2~3 个函数，打印它们的返回值或字符串信息。
2) 绑定一个带“输出指针参数”的函数（如写入版本号），正确传入地址并打印结果。
3) 把 `String` 作为输入传给 C 函数（先 `CStringRawPointer()`），让 C 函数把该字符串打印出来或处理后返回。
