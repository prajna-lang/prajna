# 容器 I：Array、DynamicArray、List

本篇介绍三类最常用容器：定长数组 `Array<T, N>`、动态数组 `DynamicArray<T>`、双向链表 `List<T>`。学完即可在 Prajna 中自如地存取、遍历与排序常见集合。

你将学到：
- `Array<T, N>`：编译期长度、索引与遍历
- `DynamicArray<T>`：运行期可变长度、Push/Pop/Resize/Length
- `List<T>`：双向链表、PushFront/Back、PopFront/Back、节点遍历
- 遍历模式与排序（结合 `Sortable`）
- 常见坑与练习

## 1. 定长数组 Array<T, N>

定义：长度 `N` 在编译期固定，元素类型为 `T`（来源：`builtin_packages/_array.prajna`）。

- 初始化与索引
```prajna
var a: Array<i64, 4> = [1,2,3,4];
a[2].PrintLine();      // 3
a[2] = 99i64;
```

- 遍历（使用索引）
```prajna
for i in 0 to 4 {
    a[i].PrintLine();
}
```

提示：`N` 为编译期常量，常用 `for i in 0 to N` 遍历。适合小型、固定尺寸的数据（如小向量、矩阵块等）。

## 2. 动态数组 DynamicArray<T>

定义：运行期可变长度的顺序容器（来源：`builtin_packages/dynamic_array.prajna`）。

- 创建与基本操作
```prajna
var d = DynamicArray<i64>::Create(0); // 初始长度 0
d.Push(10i64);
d.Push(20i64);
d.Length().PrintLine(); // 2
```

- 索引与遍历
```prajna
for i in 0 to d.Length() {
    d[i].PrintLine();
}
```

- 调整长度
```prajna
d.Resize(5i64);      // 可能填充默认值
d[4] = 42i64;
```

适用：需要追加/缩容的顺序数据。注意下标合法性与 `Resize` 的语义（长度变化不等于“容量”，按需增长）。

## 3. 双向链表 List<T>

定义：带头尾哨兵节点的双向链表（来源：`builtin_packages/list.prajna`）。

- 基本操作
```prajna
var l: List<i64>;
l.PushBack(1i64);
l.PushFront(0i64);
l.PushBack(2i64);
```

- 长度与判空（这里提供了 `Length()`）
```prajna
l.Length().PrintLine();
```

- 弹出元素
```prajna
l.PopFront();  // 删除头部元素（确保非空）
l.PopBack();   // 删除尾部元素（确保非空）
```

- 遍历（按节点指针走）
```prajna
var node = l.Begin();
while (node != l.End()) {
    node->value.PrintLine();
    node = node->next;
}
```

适用：频繁在两端插入/删除，或需要链式结构时。单次随机访问比数组慢，遍历按节点前进。

## 4. 遍历模式与注意事项

- Array/DynamicArray：用索引 `for i in 0 to len` 更高效
- List：用节点指针从 `Begin()` 走到 `End()`，不要越界访问
- 修改容器时注意迭代器/指针有效性（尤其对链表）

## 5. 排序（结合 Sortable 接口）

`builtin_packages/sortable.prajna`/`sort.prajna` 为多种容器实现了插入排序：
- `Array<T, N>`、`DynamicArray<T>`、`List<T>`、`Queue<T>`、`Stack<T>` 等均实现了 `Sortable`

- 示例：
```prajna
var arr: Array<i64, 5> = [3,1,4,1,5];
arr.Sort();         // 升序
arr.SortReverse();  // 降序

var d = DynamicArray<i64>::Create(0);
d.Push(3i64); d.Push(1i64); d.Push(2i64);
d.Sort();

a[0].PrintLine();
```

提示：`List<T>` 也实现了 `Sortable`，可直接 `l.Sort()`；插入排序适合小规模数据，海量数据请根据场景自定义更高效算法。

## 6. 常见坑与修复

- 索引越界（数组/动态数组）
  - 修复：严格使用合法范围；动态数组先 `Resize` 再写入
- 链表遍历忘记更新节点
  - 修复：每次循环末尾移动到 `node = node->next;`
- 误以为 `Length()` 是容量
  - 修复：`Length()` 是当前长度；需要更多空间时使用 `Resize` 或 `Push`
- 排序后未验证顺序
  - 修复：排序后用遍历打印或断言检查

## 7. 练习

1) 写 `func Sum(a: Array<i64, 4>)->i64` 与 `func SumD(d: DynamicArray<i64>)->i64`，分别计算和并打印。
2) 创建 `List<i64>`，按顺序插入若干值，分别用遍历打印、`Sort()`、再打印确认顺序正确。
3) 用 `DynamicArray<String>` 收集多行字符串，排序后逐行打印。

——

