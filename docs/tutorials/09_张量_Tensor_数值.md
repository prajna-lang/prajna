# 张量与数值计算

本篇介绍通用的多维数组容器 `Tensor<Type, Dim>`：如何创建、索引、打印、以及与 GPU 张量互拷。

你将学到：
- `Layout<Dim>`：`shape`（各维长度）与 `stride`（线性步长）的概念与计算
- `Tensor<Type, Dim>` 的创建、索引与打印（索引顺序、下标从 0 开始）
- 主机侧张量与 GPU 侧张量的相互拷贝（入门）
- 初始化与边界的注意事项、内存与生命周期

## 0. 什么是张量？

- 从直觉理解：张量就是“多维数组”，是标量/向量/矩阵的统一概念。
  - 标量（0 维）：`Tensor<T, 0>`（在 Prajna 中通常从 1 维开始更常见）
  - 向量（1 维）：`Tensor<T, 1>`，形状形如 `[N]`
  - 矩阵（2 维）：`Tensor<T, 2>`，形状形如 `[H, W]`
  - 更高维：`Tensor<T, 3>`（如 `[D, H, W]`），`Tensor<T, 4>`（如批量/通道/高/宽）
- 统一数据类型：一个张量内所有元素类型相同（`Type`），例如 `f32`、`i64`。
- 形状（shape）：每一维的长度；维度数（`Dim`）固定在编译期。
- 在 Prajna 中：`Tensor<Type, Dim>` 提供行主序（最后一维连续）存储、0 起始下标、多维索引 `A[i, j, ...]`，适合数值计算、图像/批量数据等场景。

## 1. 形状与步长（Layout）

张量使用 `shape` 表示各维长度，用 `stride` 把多维索引映射到线性下标。约定“最后一维”连续存储（行主序）。

- 计算规则（`Dim` 为维数）：
  - `stride[Dim-1] = 1`
  - `stride[i] = shape[i+1] * stride[i+1]`（从后往前）
- 线性下标：`linear_index = sum(idx[i] * stride[i])`

举例（二维 `[H, W] = [2, 3]`）：
- `stride = [3, 1]`
- 元素 `(0,0)` → 线性 `0*3 + 0*1 = 0`
- 元素 `(0,1)` → 线性 `0*3 + 1*1 = 1`
- 元素 `(1,0)` → 线性 `1*3 + 0*1 = 3`

再举例（三维 `[D, H, W] = [2, 3, 4]`）：
- `stride = [12, 4, 1]`
- 元素 `(d,h,w)` → 线性 `d*12 + h*4 + w`

索引顺序说明：`A[i, j]` 的 `i` 是第 0 维（高 H），`j` 是第 1 维（宽 W），下标均从 0 开始。

## 2. 创建张量与读写元素

- 创建二维 `f32` 张量 `[2,3]`，并写入元素：
```prajna
var A = Tensor<f32, 2>::Create([2,3]);
A[0,1] = 1.0f32;    // 下标 (0,1)
```

- 读取与打印
```prajna
A[0,1].PrintLine();
A.PrintLine();      // 以嵌套 [] 的形式打印整个张量（便于直观查看）
```

注意：`Create` 只分配内存，不保证内容清零；请在使用前显式赋值或初始化。

## 3. 基本操作示例：逐元素赋值与相加

- 逐元素赋值：
```prajna
func FillOnes(mat: Tensor<f32, 2>) {
    var h = mat.Shape()[0];
    var w = mat.Shape()[1];
    for i in 0 to h {
        for j in 0 to w {
            mat[i, j] = 1.0f32;
        }
    }
}
```

- 两个同形状矩阵逐元素相加：
```prajna
func Add2(A: Tensor<f32, 2>, B: Tensor<f32, 2>, C: Tensor<f32, 2>) {
    var h = A.Shape()[0];
    var w = A.Shape()[1];
    for i in 0 to h {
        for j in 0 to w {
            C[i, j] = A[i, j] + B[i, j];
        }
    }
}
```

## 4. 形状、长度与打印

- 形状：
```prajna
var shape = A.Shape();   // 例如 [2,3]
shape[0].PrintLine();    // 高 H
shape[1].PrintLine();    // 宽 W
```

- 打印：`Print()` 与 `PrintLine()` 会把多维内容格式化为 `[...]` 的层级结构（最内层为标量数组），用于调试与检查。

## 5. 与 GPU 张量交互（入门）

当执行 GPU 计算时，需要把主机侧张量拷到显存，计算完成后再拷回主机：

- 主机 -> GPU（需在支持的 GPU 环境，且加载相应平台支持后）：
```prajna
var H = Tensor<f32, 2>::Create([2,3]);
FillOnes(H);
var G = H.ToGpu();            // 上传到显存（NV/AMD 后端会提供实现）
```

- GPU -> 主机：
```prajna
var Back = G.ToHost();        // 从显存下载回主机
Back.PrintLine();
```

说明：
- ToGpu/ToHost 的可用性取决于所选 GPU 平台（例如 NV 或 AMD）；请确保在该平台运行环境中调用
- 主机侧 `Tensor` 的使用方式（创建、索引、打印）与 GPU 侧张量保持一致，便于移植

## 6. 初始化、边界与生命周期

- 初始化：`Create` 仅分配空间，内容未定义。请显式填充（如 `FillOnes`）
- 边界：索引不做自动越界检查；请确保 `0 <= idx[d] < shape[d]`
- 生命周期：张量内部的数据使用智能指针 `Ptr<Type>` 管理；当张量离开作用域、且无其它引用时，内存会被释放

## 7. 实战小练习

1) 创建两个形状为 `[4,4]` 的 `Tensor<f32, 2>`，分别用 `i+j` 与 `i-j` 填充，调用 `Add2` 把结果写入第三个张量并打印。
2) 将一个 `[32,32]` 的主机张量上传到 GPU，做一次简单的核函数运算（可参考 GPU 教程的核函数框架），再下载回主机打印前两行内容。

小提示（性能与选择）：
- 对于非常小且固定尺寸的数据，`Array<T, N>` 更轻量；对可变长或二维以上数据，`Tensor` 更易读易用
- 打印用于调试，非性能路径；数值计算请尽量采用向量化/并行的实现（如 GPU 核函数）

