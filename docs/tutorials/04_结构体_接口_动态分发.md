# 结构体、接口与动态分发（给初学者）

本篇彻底讲清三件事：
- 结构体 struct：如何定义数据、给它加方法（implement 块与 this）
- 接口 interface：只描述行为（函数签名），不关心数据
- 动态分发 Dynamic<Interface>：运行时根据真实类型决定调用哪个实现

读完你将能用 Prajna 写出清晰的面向数据/行为的代码，并正确地在“静态调用”和“动态调用”之间做选择。

建议边看边在 REPL 里尝试（`prajna repl`），或把示例写入 `.prajna` 文件执行。

## 1. 结构体：承载数据的类型

```prajna
struct Point {
    x: i64;
    y: i64;
}
```
- 结构体字段都是强/静态类型
- 字段访问通过 `this`（见下文方法）或点号：`p.x`

## 2. 给结构体“加方法”：implement 与 this

使用 `implement Type { ... }` 给类型增加方法。方法里通过 `this` 访问当前实例。

```prajna
struct Point { x: i64; y: i64; }

implement Point {
    func Length2()->i64 {
        return this.x*this.x + this.y*this.y;
    }

    func Move(dx: i64, dy: i64) {
        this.x = this.x + dx;
        this.y = this.y + dy;
    }
}

func Main(){
    var p: Point; p.x = 3i64; p.y = 4i64;
    p.Length2().PrintLine(); // 25
    p.Move(1i64, -2i64);     // p = (4,2)
    p.Length2().PrintLine(); // 20
}
```
要点：
- 写成“方法”还是“普通函数”？若需要访问 `this` 或更贴合对象语义，就放到 `implement` 里

## 3. 接口：只描述“能做什么”

接口只包含“函数签名”，不包含数据与默认实现。

```prajna
interface Say {
    func Say();
}
```
- 接口定义行为契约：任何类型只要“实现”了这些函数，就可以被当作该接口使用

## 4. 为类型实现接口：implement Interface for Type

```prajna
struct SayHi { name: String; }

implement Say for SayHi {
    func Say(){
        "Hi ".Print(); this.name.PrintLine();
    }
}
```
- 这段代码声明：`SayHi` 提供了 `Say` 接口要求的 `Say()` 行为
- 你可以为不同的类型分别实现同一个接口

完整示例（来自 `examples/interface.prajna` 的思路）：
```prajna
interface Say{ func Say(); }

struct SayHi{ name: String; }
implement Say for SayHi{ func Say(){ "Hi ".Print(); this.name.PrintLine(); } }

struct SayHello{ name: String; }
implement Say for SayHello{ func Say(){ "Hello ".Print(); this.name.PrintLine(); } }
```

## 5. 动态分发：Dynamic<Interface>

有时候我们在编写“上层代码”时，并不知道变量的真实具体类型是谁，但我们知道它“至少”实现了接口 `Say`。这时可以使用 `Dynamic<Interface>` 来进行“动态分发”。

- 将具体类型提升为接口视图：`Ptr<T>::New().As<Interface>() -> Dynamic<Interface>`
- 在 `Dynamic<Interface>` 上调用接口方法时，运行时会选择具体类型的实现

```prajna
func Main(){
    var say_hi = Ptr<SayHi>::New();
    say_hi.name = "Prajna";
    var d: Dynamic<Say> = say_hi.As<Say>();
    d.Say(); // 根据实际类型 SayHi 调用其实现

    var say_hello = Ptr<SayHello>::New();
    say_hello.name = "Paramita";
    d = say_hello.As<Say>();
    d.Say(); // 现在根据 SayHello 的实现调用
}
```

常用操作：
- 判别真实类型：`d.Is<SayHi>()`
- 安全取回具体类型：`var hi = d.Cast<SayHi>();`

```prajna
if (d.Is<SayHi>()) {
    var hi = d.Cast<SayHi>();
    hi.Say();
} else {
    var hello = d.Cast<SayHello>();
    hello.Say();
}
```

小贴士：
- `Dynamic<Interface>` 是一个具体类型，内部存放了接口方法表等信息，用来在运行时决议调用
- 不需要时，优先用静态分发（直接用具体类型的方法），更高效；需要“多态/插件化”时再使用 `Dynamic`

## 6. 选择静态 or 动态？

- 静态（直接调用具体类型方法）：性能更高，编译期确定；适合大多数情况
- 动态（`Dynamic<Interface>`）：更灵活，支持在运行时替换实现；适合策略模式、插件架构、统一处理不同实现等

## 7. 常见问题与修复

- 忘了把实现写成“实现接口”而写到了“实现类型”
  - 记法：给类型加普通方法 → `implement Type { ... }`；给类型实现接口 → `implement Interface for Type { ... }`
- 取回具体类型失败/崩溃
  - 先 `Is<T>()` 再 `Cast<T>()`；不同于 C++，非法转换会直接报错退出
- 动态分发滥用导致性能抖动
  - 能静态就静态；接口用于“需要统一抽象的场景”

## 8. 练习

1) 定义接口 `Area { func Area()->i64; }`，并为 `Rect{w,h}`、`Square{s}` 分别实现；在 `Main` 中把它们放入 `Dynamic<Area>` 列表并逐个打印面积。
2) 为 `Point{x,y}` 实现接口 `Say`，要求打印 `(x,y)`，并与 `SayHi`/`SayHello` 一起验证 `Dynamic<Say>` 的动态调用。

——

