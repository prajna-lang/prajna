# 般若编程语言 Prajna

## 前言

本文面向已经掌握至少一种编程语言的读者。如果您尚无编程基础，建议先简单学习 C 语言，或者在阅读过程中自行查阅相关资料。本文不会包含大量用例，更多代码实例请参见 `examples`、`tests/prajna_sources` 和 `builtin_packages` 目录，这些目录中有丰富的 Prajna 代码。如果您精通 C++，作者也建议适当阅读 `prajna` 目录下的编译器实现（代码量非常精炼，只有一万多行），这有助于加深对 Prajna 的理解。

## 简介

Prajna 编程语言由玄青矩阵推出，是一门通用型编程语言。Prajna 类似 C 语言，语法简洁且性能卓越，设计目标是同时覆盖 Python 和 C++ 的主流应用场景。下面简要介绍 Prajna 的主要特点。

### Prajna 的主要特性

#### 跨平台直接运行

Prajna 采用即时编译（JIT）方式，无需事先生成可执行二进制文件。代码可直接在 X86、Arm、RISC-V 等多种指令集的芯片上运行。

#### 友好交互

Prajna 支持 Main 函数、REPL 和 Jupyter 等多种运行模式，适用于软件研发、部署等多场景。

#### 极致性能

Prajna 以 LLVM 作为后端，在同等条件下性能不逊于 C++ 或 CUDA。

#### 异构编程

不同于OpenCL和CUDA在C++上的拓展, Prajna原生支持并行编程的语言, 它对GPGPU并行编程的支持会比CUDA更加友好方便, 也会支持更多的GPGPU(目前仅支持Nvidia).
在下一阶段Prajna会从语言层面集成一个自研的张量计算编译器Galois, 会对张量计算提供极具竞争力的解决方案, 兼容众多NPU/TPU.

#### 简洁的编程理念

Prajna 不刻意强调面向对象或函数式等复杂范式，而是推崇本质、极简的编程思想，这一点将在后文中有所体现。

## 入门指南

### 编译与安装

可通过 <https://github.com/prajna-lang/prajna/releases> 获取主流平台的二进制程序，将其 `bin` 目录加入可执行路径即可。如果没有适配的二进制文件，也可从源码编译安装。

#### Windows 环境配置

在 Windows 平台下需安装：

- Visual Studio（需包含 C++ 模块）
- cmake
- python
- ninja-build
- git、git lfs 及 git-bash，安装 git 时请注意勾选 bash 相关选项

#### Ubuntu 环境配置

可直接使用官方 docker 环境进行编译，或参考 [dockerfile](../dockerfiles/ubuntu_dev.dockerfile) 自行配置。下文有更详细说明。

#### 下载源码

首先下载源码。依赖库较多，请耐心等待，建议配置网络代理保证流畅下载。对于 bash 脚本和命令，Windows 平台需在 git-bash 下执行。

```bash
# 下载代码
git clone https://github.com/matazure/prajna.git
# 下载依赖库
bash ./scripts/clone_submodules.sh --jobs=16 --depth=50
```

如拉取子模块时出错，通常是 `depth` 深度未包含所需 commit，可用如下命令重新完整下载：

```bash
bash ./scripts/clone_submodules.sh --force --jobs=16
```

若遇到网络问题，请自行配置 VPN。

#### 编译

##### 环境配置

- 若使用 docker，配置好后直接运行：

```bash
bash ./scripts/start_docker_env.sh
```

- 若不使用 docker，可手动配置环境：

```bash
apt install git clang wget libgnutls28-dev libsodium-dev uuid-dev build-essential libssl-dev ninja-build
export CXX=clang++ CC=clang # 我们使用clang编译器
```

- Windows 平台需执行：

```bat
call "C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvars64.bat"
```

在编译完成前请勿退出此环境，以保证 C++ 编译器配置正确。

##### 构建与编译

```bash
bash ./scripts/configure.sh release # 配置为 release 模式
bash ./scripts/build.sh release
```

##### 测试

可通过以下指令运行测试，验证编译结果：

```bash
bash ./scripts/test.sh release # 运行测试（非必需步骤）
```

##### 安装

编译完成后的 `build_release/install` 目录即为安装包，将 `build_release/install/bin` 加入系统 PATH 即可。

### 运行方式

Prajna 提供多种运行方式，可根据场景选择适合的模式。

#### 命令行模式

可用以下指令进入命令行（REPL）模式：

```bash
prajna repl
```

类似 Python 命令行，交互体验友好：

```bash
(base) ➜  prajna repl
Prajna 0.0.0, all copyrights @ "www.github.com/matazure"
prajna > "Hello World!"                                                  1,15  ]
Hello World!
prajna >                                                                 1,1   ]
```

#### 执行 Main 函数

也可以直接执行包含 Main 函数的 prajna 文件。例如 `examples/hello_world.prajna`：

```prajna
func Main(){
    "Hello World\n".PrintLine();
}
```

运行：

```bash
prajna exe examples/hello_world.prajna
```

#### Jupyter

Prajna 支持 Jupyter 模式。请先安装 Jupyter，详见 <https://jupyter.org/>，然后执行：

```bash
prajna jupyter --install
```

完成后即可在 Jupyter 环境中愉快编程。

## 编程基础

本章介绍基本概念，这些概念在其他编程语言中同样适用。

### 变量

变量定义需指定名称和类型，也可直接赋初值（此时类型可省略）：

```prajna
var tmp0 : i64;
var tmp1 : i64 = 10i64;
var tmp2 = 100i64; // 类型可根据初始值推断
```

在使用变量前，必须用 `var` 定义。冒号后为类型名。赋值操作需类型完全一致，Prajna 不支持隐式类型转换。

```prajna
var tmp: f32;
tmp = 3.1415f32;
```

### 类型系统

Prajna 是静态强类型语言。"静态"表示类型在编译期确定，"强类型"表示类型转换需显式进行。主要包含整数型和浮点型。

#### 整型

整型支持有符号与无符号：

```prajna
var a: i64 = 3i64; // i 表示有符号，64 为位宽
var b = 128u32;    // u 表示无符号
var c = 1024;      // 默认 i64
```

支持的整型如下：

| 类型 | 有无符号 | 位宽 |
|------|----------|------|
| i8   | 有符号   | 8    |
| i16  | 有符号   | 16   |
| i32  | 有符号   | 32   |
| i64  | 有符号   | 64   |
| u8   | 无符号   | 8    |
| u16  | 无符号   | 16   |
| u32  | 无符号   | 32   |
| u64  | 无符号   | 64   |

Prajna 还支持自定义位宽：

```prajna
var big_num: Int<256>; // 256 位有符号整型
var big_num2: Unt<256>; // 256 位无符号整型
```

#### 浮点型

浮点型用于表示带小数的数值：

```prajna
var pi_f32 = 3.1415f32; // 32 位浮点数
var pi_f16 = 3.1415f16; // 16 位浮点数
var pi = 3.1415;        // 默认 f32
```

支持的浮点类型：

| 类型 | 位宽 |
|------|------|
| f16  | 16   |
| f32  | 32   |
| f64  | 64   |

常量需加类型后缀，否则默认为 i64 或 f32。

#### 算术运算

支持常见算术运算，类型需一致：

```prajna
var a = 3 + 4;
var b = 3.1415f32 * 2f32;
```

不同类型间须显式转换。

#### 布尔类型

Prajna 使用 `bool` 类型，取值为 `true` 或 `false`。

| 类型 | 标识符 | 含义 |
|------|--------|------|
| bool | true   | 真   |
| bool | false  | 假   |

支持完整逻辑运算：

```prajna
var tmp0 = true && false; // 与
var tmp1 = false || true; // 或
var tmp2 = !false;        // 非
```

#### 指针

`ptr<i64>` 表示 i64 类型的指针，类似 C 语言的 `i64*` ：

```prajna
var tmp = 1024;
var p: ptr<i64> = &tmp; // 取地址
*p = 1025;              // 解引用赋值
```

更多用法详见 `tests/prajna_sources/ptr_test.prajna` 或 `builtin_packages`。

#### 数组

`array<Type, Length>` 表示数组，等价于 C 的 `Type tmp[Length]`：

```prajna
var array_tmp: array<i64, 3>; // i64 类型，长度 3
var array_tmp = [1.0, 2.0, 3.0]; // 自动推断类型为 f32，长度为 3
```

### 函数

函数定义如下：

```prajna
func Add(v0: i64, v1: i64) -> i64 {
    return v0 + v1;
}

func PrintHi() { // 无返回值类型
    "Hi".Print();
}
```

`func` 关键字后为参数及类型，`->` 后为返回值类型。函数主体可包含声明与表达式。

### 控制流

Prajna 提供三种常用控制流：if-else、while、for。

#### if-else

条件分支，与 C 类似：

```prajna
var a = 3;
var re = 0;
if (a > 0) {
    re = 1;
} else {
    re = -1;
}
```

#### while

用法同 C：

```prajna
var i = 0;
while (i < 100) {
    i = i + 1;
}
```

#### for

语法与 C 不同：

```prajna
var sum = 0;
for i in 0 to 100 { // i 遍历区间 [0, 100)，不含 100
    sum = sum + i;
}
```

### 注释

注释风格同 C：

```prajna
// 单行注释
/*
多行
注释
*/
```

## 结构体

自定义结构体如下所示：

```prajna
struct Point{
    x: f32;
    y: f32;
}
```

通过 `.` 运算符访问字段：

```prajna
var origin: Point;
origin.x = 0.0;
origin.y = 0.0;
```

### 成员函数

成员函数采用外部扩展的形式（类似 Rust、Swift）：

```prajna
implement Point{
    func Norm() -> f32 {
        return this.x * this.x + this.y * this.y; // this 指向自身
    }
}
```

成员函数自动拥有 `this` 对象。调用方式：

```prajna
var dis = Point(100.0, 100.0);
var norm = dis.Norm();
```

成员函数实质上是普通函数的语法糖，隐式传递 `this`。

### 静态成员函数

用 `@static` 修饰可定义静态成员函数，通过类型访问：

```prajna
implement Point{
    @static
    func Create() {
        var self: Point;
        self.x = 0.0;
        self.y = 0.0;
        return self;
    }
}

var zero_point = Point::Create();
```

### 运算符重载

通过特殊命名函数实现运算符重载：

#### 二元运算符

| 函数名              | 运算符 |
|---------------------|--------|
| \_\_equal\_\_           | ==     |
| \_\_not_equal\_\_       | !=     |
| \_\_less\_\_            | <      |
| \_\_less_or_equal\_\_   | <=     |
| \_\_greater\_\_         | >      |
| \_\_greater_or_equal\_\_| >=     |
| \_\_add\_\_             | +      |
| \_\_sub\_\_             | -      |
| \_\_multiply\_\_        | *      |
| \_\_divide\_\_          | /      |
| \_\_remaind\_\_         | %      |
| \_\_and\_\_             | &      |
| \_\_or\_\_              | \|     |
| \_\_xor\_\_             | ^      |

#### 一元前缀运算符

| 函数名         | 运算符 |
|----------------|--------|
| \_\_not\_\_        | !      |
| \_\_positive\_\_   | +      |
| \_\_negative\_\_   | -      |

详见 `builtin_packages/primitive_type.prajna`。

### 属性

通过 `__set__` 和 `__get__` 前缀函数实现属性：

```prajna
struct People{
    _age: i64;
}

implement People{
    func __get__Age() -> i64 {  // 取值函数
        return this._age;
    }

    func __set__Age(v: i64) {  // 赋值函数
        this._age = v;
    }
}

func Main(){
    var people: People;
    people.Age = 18; // 等价于 people.__set__Age(18)
    var age = people.Age; // 等价于 people.__get__Age()
}
```

属性是简化 get/set 调用的语法糖，也支持 `[]` 下标等。

## 函数指针与虚表（VTable）

Prajna 支持将函数作为一等公民进行赋值、存储和调用。通过函数指针（function type）与数组等容器结合，可以实现类似虚表（VTable）的机制，支持运行时动态调用不同的函数。这为实现回调、事件驱动、插件等模式提供了基础能力。

### 基本语法

- `function<Signature>` 类型用于表示函数指针，可存储任意签名匹配的函数。
- 可以将函数直接赋值给 `function` 类型变量或数组元素，通过下标访问并调用。

#### 示例

```prajna
func SayHi() {
    "Hi\n".Print();
}

func SayHello() {
    "Hello\n".Print();
}

@test
func TestMain() {
    var vtable: array<function<void>, 2>;
    vtable[0] = SayHi;
    vtable[1] = SayHello;

    vtable[0]();
    vtable[1]();
}
```

- 这里 `array<function<void>, 2>` 创建了一个函数指针数组。
- 可以像普通函数一样将函数赋值给数组元素。
- 通过 `vtable[0]()` 方式动态调用对应函数，实现类似虚表（VTable）的行为。

## 资源管理

现代编程语言的重要特性之一是资源管理，Prajna 内置了自动化机制（如智能指针）实现内存自动管理。

### 智能指针

```prajna
func Main() {
    var mem = Ptr<i64>::Allocate(1024); // 分配内存
    mem.ReferenceCount().PrintLine(); // 引用计数为1
    {
        var t = mem;
        mem.ReferenceCount().PrintLine(); // 引用计数为2
    }
    mem.ReferenceCount().PrintLine(); // 引用计数为1
    // 离开作用域后引用计数为0，自动释放内存
}
```

### 使用 WeakPtr 解决循环引用

在基于引用计数的智能指针系统中，循环引用会导致内存无法释放。例如，两个对象互相持有对方的智能指针时，两者的引用计数都不会归零，内存泄漏。为解决此问题，Prajna 提供了 WeakPtr（弱引用指针）类型，用于打破这种循环依赖。

#### 示例：使用 WeakPtr 打破循环引用

```prajna
template <Type>
struct Node{
    object: Type;
    next_shared: Ptr<Node<Type>>;
    next_weak: WeakPtr<Node<Type>>;
}

@test
func TestCircularReference() {
   var node0: Node<i64>;
   node0.object = 1024;

   var node1: Node<i64>;
   node1.object = 4201;

   var node0_ptr = Ptr<Node<i64>>::New();
   node0_ptr.raw_ptr = &node0;

   var node1_shared_ptr = Ptr<Node<i64>>::New();
   node1_shared_ptr.raw_ptr = &node1;
   var node1_ptr = WeakPtr<Node<i64>>::FromPtr(node1_shared_ptr);

   test::Assert(node0_ptr.ReferenceCount() == 1);
   test::Assert(node1_ptr.ReferenceCount() == 1);

   node0.next_weak = node1_ptr;        // 弱引用，不增加强引用计数
   node1.next_shared = node0_ptr;      // 强引用，增加计数

   test::Assert(node0_ptr.ReferenceCount() == 2);
   test::Assert(node1_ptr.ReferenceCount() == 1);
}
```

在上述代码中，`node0.next_weak` 为 `WeakPtr`，不会增加 `node1` 的引用计数，从而打破了循环引用，保证内存可以正确释放。

### 自动回调机制

`__initialize__`、`__copy__`、`__finalize__` 三个函数由系统自动调用：

1. 定义变量时触发 `__initialize__`
2. 赋值时，右值触发 `__copy__`，左值触发 `__finalize__`
3. 变量离开作用域时触发 `__finalize__`
4. return 时触发 `__copy__`

智能指针、String、List 等资源管理均基于此机制。

**例如，双向链表 List 的自动回调机制如下：**

```prajna
template <ValueType>
struct List {
    _head: ptr<Node<ValueType>>;
    _end: ptr<Node<ValueType>>;
    // 用于引用计数
    _reference_counter : ptr<i64>;
}

template <ValueType>
implement List<ValueType> {
    func __initialize__() {
        this._head = ptr<Node<ValueType>>::New();
        this._end = ptr<Node<ValueType>>::New();
        this._head->prev = ptr<Node<ValueType>>::Null();
        this._head->next = this._end;
        this._end->prev =  this._head;
        this._end->next = ptr<Node<ValueType>>::Null();

        this._reference_counter = ptr<i64>::New();
        *this._reference_counter = 1;
    }

    func __copy__() {
        *this._reference_counter = *this._reference_counter + 1;
    }

    func __finalize__() {
        *this._reference_counter = *this._reference_counter - 1;
        if (*this._reference_counter == 0){
            this._reference_counter.Free();

            var node = this.Begin();
            while (node != this.End()) {
                node->prev.Free();
                node = node->next;
            }
            this.End().Free();
        }
    }
}
```

- `__initialize__`：创建头尾哨兵节点、初始化引用计数。
- `__copy__`：复制时增加引用计数，实现多份 List 共享数据。
- `__finalize__`：引用计数归零时，依次释放所有节点及计数内存，确保链表不泄漏。

这一机制确保了复杂结构如 List 也能自动安全地管理资源，无需手动释放。

## 单元（Module）

Prajna 使用模块（Module）组织程序，类似 C++ 的 namespace，但通常自动根据文件路径生成模块名，无需手动声明。

路径 `test1/test2/test3.prajna` 的模块名为 `test1::test2::test3`。子模块可访问父模块的符号（函数、结构等）。

`.prajna` 文件不会生成模块名，`test/.prajna` 和 `test.prajna` 的模块组织一致，均为 `test`。

可用 `module` 显式创建模块：

```prajna
module A {
    func Test() {}
}

A::Test(); // 通过 :: 访问模块内函数

use A::Test; // 导入符号
Test(); // 可直接使用

use A::Test as A_Test; // 导入并重命名
A_Test();
```

## 接口

Prajna 拥有类似 C#、Rust 的接口（interface）机制，原理与 C++ 虚函数类似，用于动态分发与多态。

```prajna
interface Say{
    func Say();
}

struct SayHi{
    name: String;
}

implement Say for SayHi{
    func Say() {
        "Hi ".Print();
        this.name.PrintLine();
    }
}

struct SayHello{
    name: String;
}

implement Say for SayHello{
    func Say(){
        "Hello ".Print();
        this.name.PrintLine();
    }
}

func Main(){
    var say_hi = Ptr<SayHi>::New();
    say_hi.name = "Prajna";
    say_hi.Say();
    var d_say: Dynamic<Say> = say_hi.As<Say>(); // Dynamic<Say> 存储 Say 接口的函数
    d_say.Say();

    var say_hello = Ptr<SayHello>::New();
    say_hello.name = "Paramita";
    say_hello.Say();
    d_say = say_hello.As<Say>();
    d_say.Say();

    // 转换前需判断类型；与 C++ 不同，转换失败将报错退出
    if (d_say.Is<SayHi>()) {
        var say_hi2 = d_say.Cast<SayHi>();
        say_hi2.Say();
        say_hi.name = "Prajna2 ";
    } {
        var say_hello2 = d_say.Cast<SayHello>();
        say_hello2.Say();
        say_hello2.name = "Paramita2 ";
    }

    d_say.Say();
}
```

Prajna 多态语法做了不少简化与优化。

## 模板

Prajna 模板由模板参数和代码两部分组成。使用模板时，需传入具体参数，编译器据此生成相应代码。

### 模板结构体

```prajna
template <ValueType> // ValueType 为模板参数
struct Point{
    x: ValueType;
    y: ValueType;
}

template <ValueType>
implement Point<ValueType> { // Point 须带上模板参数
    func Norm2() -> ValueType {
        return (this.x * this.x + this.y * this.y).Sqrt();
    }
}

func Main() {
    var point_f32: Point<f32>;
    point_f32.x = 1.0;
    point_f32.y = 2.0;
    point_f32.Norm2().PrintLine();
}
```

### 模板函数

```prajna
template <Type>
func Add(v0: Type, v1: Type) -> Type{
    return v0 + v1;
}

func Main() {
    Add<i32>(0i32, 1i32).PrintLine(); // 与其他语言不同，Prajna 模板需显式给出实参
    Add<f32>(2f32, 3f32).PrintLine();
}
```

虽然 Prajna 支持多种模板，但模板机制并不复杂。

## 内置数据结构

## 字典（Dict）

Prajna 支持多种字典（映射）结构，适用于不同需求的键值对存储。以下是一个基于链表的简单字典实现（ListDict），适合用于数据量较小或顺序敏感的场景。

### Dict 结构定义与核心操作

此实现通过 `List<KeyValue<Key, Value>>` 存储所有键值对，支持插入和按键查找。

```prajna
use list::List;

template <Key, Value>
struct KeyValue{
    key: Key;
    value: Value;
}

template <Key, Value>
struct ListDict {
    _key_value_list: List<KeyValue<Key, Value>>;
}

template <Key, Value>
implement ListDict<Key, Value> {

    func Get(key: Key)->Value { ... }

    func Insert(key: Key, value: Value) { ... }
}
```

- `Insert(key, value)`：将键值对插入链表头部，时间复杂度 O(1)。
- `Get(key)`：遍历链表查找对应键，返回值，未找到时断言失败，时间复杂度 O(n)。

#### DynamicArray 结构定义与核心操作

```prajna
template <ElementType>
struct DynamicArray {
    _data: ptr<ElementType>;
    _size: i64;
    _capacity: i64;
}

template <ElementType>
implement DynamicArray<ElementType> {
    func __initialize__() { ... }

    func PushBack(value: ElementType) { ... }

    func PopBack() { ... }

    func At(index: i64) -> ElementType { ... }

    func Set(index: i64, value: ElementType) { ... }

    func Insert(index: i64, value: ElementType) { ... }

    func Remove(index: i64) { ... }

    func Clear() { ... }

    func Length() -> i64 { ... }

    func Capacity() -> i64 { ... }

    func IsEmpty() -> bool { ... }
}
```

- 内部通过 `_data` 指针管理实际存储空间，`_size` 记录当前元素个数，`_capacity` 为当前分配的内存容量。
- `PushBack(value)`：在数组尾部插入元素，必要时自动扩容。
- `PopBack()`：移除数组末尾元素。
- `At(index)`：返回指定下标的元素。
- `Set(index, value)`：设置指定下标的元素值。
- `Insert(index, value)`：在指定位置插入元素，其后元素后移。
- `Remove(index)`：移除指定位置的元素，其后元素前移。
- `Clear()`：清空数组所有元素。
- `Length()`：返回当前元素数量。
- `Capacity()`：返回当前容量（已分配的最大元素数）。
- `IsEmpty()`：判断数组是否为空。

DynamicArray 提供灵活且高效的动态数组能力，适用于需要频繁插入、删除、随机访问的场景。

### 哈希字典（HashDict）

Prajna 提供了泛型哈希表（HashDict）数据结构，用于实现高效的键值对存储和查找。HashDict 适用于需要常数时间插入、查找和删除的场景，支持自动扩容和冲突链式解决。

#### HashDict 结构定义与核心操作

```prajna
template <KeyType,ValueType>
struct HashDictNode{
  key : KeyType;
  value : ValueType;
  next: ptr<HashDictNode<KeyType, ValueType>>;
}

template <KeyType,ValueType>
struct HashDict {
  buckets: Ptr<ptr<HashDictNode<KeyType, ValueType>>>;
  size: i64;
  count: i64;
  load_factor_threshold: f64;
}

template <KeyType,ValueType>
implement HashDict<KeyType,ValueType> {
  func __initialize__() { ... }

  func IsEmpty() -> bool { ... }

  func Hash_index(key: KeyType) -> i64 { ... }

  func Insert_node(key: KeyType, value: ValueType) { ... }

  func Get(key: KeyType) -> ValueType { ... }

  func Remove(key: KeyType) { ... }

  func Clear() { ... }
}
```

- 内部采用链式哈希桶(`buckets`)存储节点，解决哈希冲突。
- `Insert_node(key, value)`：将键值对插入哈希表，对冲突采用链表解决，必要时可扩容重哈希。
- `Get(key)`：查找指定键对应的值，若不存在可断言失败或返回默认值。
- `Remove(key)`：删除指定键对应的节点。
- `Clear()`：清空所有元素，释放所有节点内存。
- `IsEmpty()`：判断字典是否为空。
- `Hash_index(key)`：返回键对应的哈希桶索引。当前实现直接将 key 强转为 i64 后取模，实际应用中建议实现更健壮的哈希函数。

### 堆（Heap）

Prajna 标准库实现了模板化的堆（Heap）数据结构，支持最大堆和最小堆的灵活切换。堆适用于优先队列、排序、调度等对最大（最小）值频繁操作的场合，具有插入和取出极值的对数复杂度。

#### Heap 结构定义与核心操作

```prajna
template <Type, MaxSize>
struct Heap {
    data: Array<Type, MaxSize>;
    size: i64;
    is_max_heap: bool;  // true 为最大堆，false 为最小堆
}

template <Type, MaxSize>
implement Heap<Type, MaxSize> {
    @static
    func New() -> Heap<Type, MaxSize> { ... }

    func ParentIndex(idx: i64) -> i64 { ... }

    func LeftChildIndex(idx: i64) -> i64 { ... }

    func RightChildIndex(idx: i64) -> i64 { ... }

    func Size() -> i64 { ... }

    func IsEmpty() -> bool { ... }

    func IsMaxHeap() -> bool { ... }

    func Compare(a: Type, b: Type) -> bool { ... }

    func Peek() -> Type { ... }

    func Push(value: Type) { ... }

    func HeapifyDown(idx: i64) { ... }

    func Pop() -> Type { ... }
}
```

- 内部通过 `Array<Type, MaxSize>` 数组实现堆结构，`size` 记录当前元素数量，`is_max_heap` 控制堆类型（最大堆/最小堆）。
- `New()`：创建并初始化空堆。
- `Push(value)`：插入新元素，自动维护堆性质，O(log n)。
- `Pop()`：弹出堆顶元素（最大或最小），自动维护堆性质，O(log n)。
- `Peek()`：返回堆顶元素但不移除。
- `IsMaxHeap()`：判断是否最大堆。
- `IsEmpty()`、`Size()`：判断堆是否为空、获取元素数量。
- `Compare(a, b)`：根据堆类型比较优先级，最大堆为大于，最小堆为小于。
- `HeapifyDown(idx)`：自顶向下维护堆性质（用于 Pop 操作）。
- `ParentIndex(idx)`、`LeftChildIndex(idx)`、`RightChildIndex(idx)`：堆节点间的索引关系。

#### 特性说明

- 默认构造为最大堆（`is_max_heap = true`），可通过修改属性切换为最小堆。

### 链表（List）

Prajna 标准库实现了模板化的双向链表（List）结构，支持高效的头尾插入、删除和遍历等常用链表操作。List 采用引用计数自动内存管理，适用于需要动态插入、删除、顺序遍历的数据场景。

#### List 结构定义与核心操作

```prajna
template <ValueType>
struct Node {
    next: ptr<Node<ValueType>>;
    prev: ptr<Node<ValueType>>;
    value: ValueType;
}

template <ValueType>
implement Node<ValueType> {
    func InsertBefore(value: ValueType) { ... }
    func InsertAfter(value: ValueType) { ... }
    func RemoveBefore() { ... }
    func RemoveAfter() { ... }
}

template <ValueType>
struct List {
    _head: ptr<Node<ValueType>>;
    _end: ptr<Node<ValueType>>;
    // 用于引用计数
    _reference_counter : ptr<i64>;
}

template <ValueType>
implement List<ValueType> {
    func PushFront(value: ValueType) { ... }
    func PushBack(value: ValueType) { ... }
    func PopFront() { ... }
    func PopBack() { ... }
    func End() -> ptr<Node<ValueType>> { ... }
    func Begin() -> ptr<Node<ValueType>> { ... }
    func Length() -> i64 { ... }
    func __initialize__() { ... }
    func __copy__() { ... }
    func __finalize__() { ... }
}
```

- 内部通过双向链表节点（Node）组织元素，_head 为头哨兵节点，_end 为尾哨兵节点。
- 自动引用计数管理链表内存，支持多份 List 共享底层节点。
- `PushFront(value)`：在链表头部插入元素，O(1)。
- `PushBack(value)`：在链表尾部插入元素，O(1)。
- `PopFront()`：删除链表头节点，O(1)，需保证链表非空。
- `PopBack()`：删除链表尾节点，O(1)，需保证链表非空。
- `Begin()`/`End()`：返回链表起始、结束节点指针，可用于遍历。
- `Length()`：返回链表元素数量，O(n)。
- `__initialize__`/`__copy__`/`__finalize__`：自动内存与资源管理，见下说明。

### 队列（Queue）

Prajna 标准库实现了模板化的队列（Queue）结构，底层基于双向链表（List），可高效地支持元素的先进先出（FIFO）操作。Queue 适合于生产者-消费者模型、任务调度、广度优先遍历等场景。

#### Queue 结构定义与核心操作

```prajna
template <ValueType>
struct Queue {
    _list: List<ValueType>;
}

template <ValueType>
implement Queue<ValueType> {
    func IsEmpty() -> bool { ... }
    func Enqueue(value: ValueType) { ... }
    func Dequeue() -> ValueType { ... }
    func Length() -> i64 { ... }
    func Peek() -> ValueType { ... }
    func Back() -> ValueType { ... }
    func Clear() { ... }
}
```

- 内部通过 `List<ValueType>` 实现所有操作，保证队列操作的高效性和安全的资源管理。
- `IsEmpty()`：判断队列是否为空。
- `Enqueue(value)`：入队操作，将元素加入队列尾部。
- `Dequeue()`：出队操作，移除并返回队列头部的元素。
- `Peek()`：返回队首元素但不移除。
- `Back()`：返回队尾元素但不移除。
- `Length()`：返回队列中元素数量。
- `Clear()`：清空队列中所有元素。

## 集合(Set)

Prajna 标准库实现了通用的集合(Set)结构，支持高效的元素去重、查找和集合运算。Set 基于哈希表（HashDict）实现，适用于需要唯一性约束和集合操作的场景。

### Set 结构定义与核心操作

```prajna
template <ElementType>
struct Set {
    dict: HashDict<ElementType, bool>;
}

template <ElementType>
implement Set<ElementType> {
    func __initialize__() {
        this.dict.__initialize__();
    }

    func Contains(element: ElementType) -> bool { ... }

    func Add(element: ElementType) { ... }

    func Remove(element: ElementType) { ... }

    func IsEmpty() -> bool { ... }

    func Count() -> i64 { ... }

    func Union(other: Set<ElementType>) -> Set<ElementType> { ... }

    func Intersection(other: Set<ElementType>) -> Set<ElementType> { ... }

    func Difference(other: Set<ElementType>) -> Set<ElementType> { ... }
}
```

- 内部采用 `HashDict<ElementType, bool>` 存储元素，实现高效的插入、查找和删除。
- `Add`：向集合插入元素，自动去重。
- `Remove`：删除元素。
- `Contains`：判断元素是否存在。
- `Union`：返回当前集合与另一个集合的并集。
- `Intersection`：返回当前集合与另一个集合的交集。
- `Difference`：返回当前集合与另一个集合的差集。
- `Count`：返回集合中元素数量。
- `IsEmpty`：判断集合是否为空。

### 栈（Stack）

Prajna 标准库实现了模板化的栈（Stack）结构，底层基于双向链表（List），支持高效的后进先出（LIFO）操作。Stack 适用于递归、回溯、表达式求值等需要栈结构的场景。

#### Stack 结构定义与核心操作

```prajna
use list::List;

template <ValueType>
struct Stack {
    _list: List<ValueType>;
}

template <ValueType>
implement Stack<ValueType> {
    func IsEmpty() -> bool { ... }
    func Push(value: ValueType) { ... }
    func Pop() { ... }
    func Top() -> ValueType { ... }
}
```

- 内部通过 `List<ValueType>` 实现所有操作，保证栈操作的高效性和安全的资源管理。
- `IsEmpty()`：判断栈是否为空。
- `Push(value)`：将元素压入栈顶。
- `Pop()`：弹出栈顶元素（并移除），在栈空时断言失败。
- `Top()`：返回栈顶元素但不移除，在栈空时断言失败。

### 字符串（String）

Prajna 标准库实现了可变字符串类型 `String`，底层基于动态数组（DynamicArray<char>），支持灵活的字符串操作和扩展。该实现兼容 C 风格字符串，方便与底层库交互。

#### String 结构定义与核心操作

```prajna
struct String{
    darray: DynamicArray<char>;
}

implement String {
    func __get_linear_index__(idx: i64) -> char { ... }
    func __set_linear_index__(idx: i64, value: char) { ... }
}

implement String {
    @static
    func Create(length: i64) -> String { ... }
    func Length() -> i64 { ... }
    @static
    func __from_char_ptr(cstr_ptr: ptr<char>) -> String { ... }
    func CStringRawPointer() -> ptr<char> { ... }
    func Print() { ... }
    func Push(v: char) { ... }
    func Pop() { ... }
    func Resize(length: i64) { ... }
    func PrintLine() { ... }
    func ToString() -> String { ... }
}

implement String {
    func __add__(str_re: String) -> String { ... }
}

implement String {
    func __equal__(rhs_str: String) -> bool { ... }
}

implement String {
    func __not_equal__(rhs_str: String) -> bool { ... }
}
```

- `darray`：底层通过动态数组管理字符串内容，自动管理容量和末尾 `\0`。
- `Create(length)`：创建指定长度的字符串，自动分配空间并以 `\0` 结尾。
- `Length()`：返回字符串实际字符数（不含末尾 `\0`）。
- `Push(v)`/`Pop()`：在尾部追加/删除字符，同时维护 `\0` 结尾。
- `Resize(length)`：调整字符串长度，自动处理底层空间。
- `__add__`：拼接两个字符串，返回新的字符串对象。
- `__equal__`/`__not_equal__`：字符串比较，逐字符判断内容是否相同。
- `Print()`/`PrintLine()`：打印字符串内容（行尾自动加换行）。
- `CStringRawPointer()`：返回底层 C 风格 null 结尾字符指针，便于与底层库交互。
- `__from_char_ptr(cstr_ptr)`：从 C 字符串指针创建 Prajna 字符串。

#### 特性说明

- 所有操作均自动保证字符串以 `\0` 结尾，兼容 C/C++ 库。
- 随时可通过下标访问和修改字符。
- 字符串相加、比较等操作均为值语义，生成新的字符串对象。
- 提供与底层 C 字符串的互操作能力。

### 张量（Tensor）

Prajna 标准库实现了通用的多维数组（张量，Tensor）结构，支持任意维度的高效线性存储、索引转换与打印。Tensor 适用于机器学习、科学计算、图像处理等多维数据场景。

#### Layout 结构定义与核心操作

`Layout<Dim>` 用于描述多维张量的形状与线性地址映射关系。

```prajna
template <Dim>
struct Layout{
    shape: Array<i64, Dim>;
    stride: Array<i64, Dim>;
}

template <Dim>
implement Layout<Dim> {
    @static
    func Create(shape: Array<i64, Dim>) -> Layout<Dim> { ... }
    func LinearIndexToArrayIndex(offset: i64) -> Array<i64, Dim> { ... }
    func ArrayIndexToLinearIndex(idx: Array<i64, Dim>) -> i64 { ... }
    func Length() -> i64 { ... }
}
```

- `shape`：每一维的长度。
- `stride`：每一维的跳步，用于多维索引到线性索引的转换。
- `Create(shape)`：根据 shape 自动生成 stride 信息，支持任意维度。
- `ArrayIndexToLinearIndex(idx)` / `LinearIndexToArrayIndex(offset)`：多维索引与线性内存偏移转换。
- `Length()`：张量元素总数。

#### Tensor 结构定义与核心操作

`Tensor<Type, Dim>` 为泛型多维数组实现，支持高效随机访问与打印。

```prajna
template <Type, Dim>
struct Tensor {
    data : Ptr<Type>;
    layout: Layout<Dim>;
}

template <Type, Dim>
implement Tensor<Type, Dim> {
    @static
    func Create(shape: Array<i64, Dim>) -> Tensor<Type, Dim> { ... }
    func Shape() -> Array<i64, Dim> { ... }
    func __get__At(idx: Array<i64, Dim>) -> Type { ... }
    func __set__At(idx: Array<i64, Dim>, value: Type) { ... }
    func __get_array_index__(idx: Array<i64, Dim>) -> Type { ... }
    func __set_array_index__(idx: Array<i64, Dim>, value: Type) { ... }
    func Print() { ... }
    func PrintLine() { ... }
}

template <Type, Dim>
implement Serializable for Tensor<Type, Dim> {
    func ToString() -> String { ... }
}
```

- `data`：实际内存存储，线性分配。
- `layout`：描述 shape 和 stride，支持高效索引和遍历。
- `Create(shape)`：创建指定形状的张量，自动分配内存。
- `Shape()`：返回张量形状。
- `__get__At(idx)` / `__set__At(idx, value)`：多维索引访问或赋值。
- `ToString()`/`Print()`/`PrintLine()`：以嵌套数组格式序列化和输出张量内容，适合可视化。
- 支持序列化接口（Serializable），可与字符串类型无缝转换和打印。

## 内置数据结构的排序与多态接口

Prajna 通过接口（interface）机制实现了对多种内置数据结构的统一排序功能。只要实现了 `Sortable` 接口的数据结构，都可以直接调用 `Sort()` 和 `SortReverse()` 方法进行正序或逆序排序。

### Sortable 接口定义与实现

```prajna
interface Sortable {
    func Sort();
    func SortReverse();
}
```

#### Array、DynamicArray、List、Queue、Stack、String 的排序

Prajna 为以下内置数据结构实现了 `Sortable` 接口：

- `Array<Type, Length_>`
- `DynamicArray<ValueType>`
- `List<ValueType>`
- `Queue<ValueType>`
- `Stack<ValueType>`
- `String`

这些实现采用插入排序（Insertion Sort）算法，对各自的数据结构进行了适配。例如 `Array` 和 `DynamicArray` 按下标访问，`List` 使用链表节点遍历，`Queue` 和 `Stack` 则通过其底层链表实现排序。

#### 典型实现示例

以 Array 排序为例：

```prajna
template <Type, Length_>
implement Sortable for Array<Type, Length_> {
    func Sort() {
        for i in 1 to Length_ {
            var key = this[i];
            var j = i - 1;

            while j >= 0 && this[j] > key {
                this[j + 1] = this[j];
                j = j - 1;
            }
            this[j + 1] = key;
        }
    }

    func SortReverse() {
        for i in 1 to Length_ {
            var key = this[i];
            var j = i - 1;

            while j >= 0 && this[j] < key {
                this[j + 1] = this[j];
                j = j - 1;
            }
            this[j + 1] = key;
        }
    }
}
```

其它容器（如 `List`、`Queue`、`Stack`）的排序实现可参考源码，均提供了符合各自结构特点的插入排序。

### 通用排序调用

由于各容器都实现了 `Sortable` 接口，只需一行代码即可对其排序：

```prajna
var arr: Array<i64, 5> = [1, 2, 3, 4, 5];
arr.Sort();         // 升序排列
arr.SortReverse();  // 降序排列
```

这也支持多态调用，无需关心底层数据结构的具体类型。

## 闭包（匿名函数）

Prajna 支持闭包（匿名函数），语法糖相对复杂：

```prajna
func Main() {
    var f = (){
        "Hello World!".PrintLine();
    };
    f();

    var add = (a: i64, b: i64) -> i64 {
        return a + b;
    };
    add(2, 3).PrintLine();

    var x = 100;
    var capture_add = (v: i64) -> i64 {
        return v + x; // 会自动捕获使用到的变量
    };
    capture_add(10).PrintLine();
}
```

## 文件读写接口

Prajna 提供了简洁的文件读写接口，便于以字符串形式高效地读写文本或二进制数据。底层通过 C 标准库文件流封装，兼容绝大多数平台。

#### 主要接口

- `fs::Write(filename: String, buffer: String)`
  将字符串内容写入指定文件，若文件不存在则会自动创建，内容会被覆盖。
- `fs::Read(filename: String) -> String`
  读取整个文件内容为字符串。

#### 典型用法

```prajna
use fs;

@test
func TestFs() {
    var str_hello_world = "Hello World!";
    // 写入字符串到文件
    fs::Write(".fs_test.txt", str_hello_world);

    // 从文件读取字符串
    var str = fs::Read(".fs_test.txt");
    __assert(str == str_hello_world); // 断言读写一致
}
```

#### 说明

- 文件以二进制模式（`wb+` / `rb`）打开，支持任意内容的读写。
- 写入时会覆盖原有文件内容；读取时一次性载入全部数据。
- 适合快速实现序列化、配置文件、数据导出/导入等功能。

#### 底层实现简述

```
struct FILE{}

func fopen(filename: ptr<char>, mode: ptr<char>)->ptr<FILE>;
func fclose(stream: ptr<FILE>);
func fseek(stream: ptr<FILE>, offset: i64, origin: i32);
func ftell(stream: ptr<FILE>)->i64;
func fflush(stream: ptr<FILE>);
func fread(buffer: ptr<char>, size: i64, count: i64, stream: ptr<FILE>);
func fwrite(buffer: ptr<char>, size: i64, count: i64, stream: ptr<FILE>);
```

- 封装了 C 标准库 `fopen`, `fwrite`, `fread`, `fseek`, `ftell` 等接口。
- `fs::Write` 自动将字符串转为 C 字符串指针并写入。
- `fs::Read` 自动分配合适长度的字符串缓冲区并读入全部内容。

## 包管理

Prajna 推荐直接用 git 作为包管理工具，后续将提供最佳实践指南。目前可手动拷贝相关文件夹。

## GPU 并行编程

Prajna 的 GPU 并行编程理念与 CUDA、OpenCL 基本一致。若无相关基础建议先查阅相关资料。

```prajna
use ::gpu::*;
use ::gpu::Tensor<f32, 2> as GpuMatrixf32;

@kernel // 标注核函数
@target("nvptx")
func MatrixMultiply(A: GpuMatrixf32, B: GpuMatrixf32, C: GpuMatrixf32) {
    var thread_x = ::gpu::ThreadIndex()[1];
    var thread_y = ::gpu::ThreadIndex()[2];
    var block_x = ::gpu::BlockIndex()[1];
    var block_y = ::gpu::BlockIndex()[2];
    var block_size = 32;
    var global_x = block_x * block_size + thread_x;
    var global_y = block_y * block_size + thread_y;

    var sum = 0.0f32;
    var step = A.Shape()[1] / block_size;
    for i in 0 to step {
        @shared
        var local_a: Array<f32, 1024>;
        @shared
        var local_b: Array<f32, 1024>;
        local_a[thread_x* 32 + thread_y] = A[global_x, thread_y + i * block_size];
        local_b[thread_x* 32 + thread_y] = B[thread_x + i * block_size , global_y];
        ::gpu::BlockBarrier();

        for j in 0 to 32 {
          sum = sum + local_a[thread_x * 32 + j] * local_b[j * 32 + thread_y];
        }
        ::gpu::BlockBarrier();
    }

    C[global_x, global_y] = sum;
}

@test
func Main() {
    var block_size = 32;
    var block_shape = [1, block_size, block_size]; // 注意与 cuda 的 dim 顺序相反，[z, y, x]
    var a_shape = [10 * 32, 10 * 32];
    var b_shape = [10 * 32, 20 * 32];
    var grid_shape = [1, a_shape[0] / block_size, b_shape[1] / block_size];

    var A = GpuMatrixf32::Create(a_shape);
    var B = GpuMatrixf32::Create(b_shape);
    var C = GpuMatrixf32::Create([a_shape[0], b_shape[1]]);

    MatrixMultiply<|grid_shape, block_shape|>(A, B, C);
    gpu::Synchronize(); // 后续将更名为通用名字

    var epoch = 300;
    var t0 = chrono::Clock();

    for i in 0 to epoch {
      MatrixMultiply<|grid_shape, block_shape|>(A, B, C); // 核函数调用，语法有所简化
    }
    gpu::Synchronize(); // 后续将更名为通用名字

    var t1 = chrono::Clock();
    t0.PrintLine();
    t1.PrintLine();

    var flops = 2 * a_shape[0] * a_shape[1] * b_shape[1];
    var giga_flops = (flops.Cast<f32>() * 1.0e-9 * epoch.Cast<f32>()) / (t1 - t0);
    giga_flops.Print();
    "GFlop/s".PrintLine();
}
```

## 特殊指令

Prajna 支持以 `#` 开头的特殊指令，主要用于编译期间执行操作：

```prajna
#error("...");   // 输出错误信息
#warning("..."); // 输出警告信息
#system("...");  // 执行终端命令，通常用于交互环境
```

## 调用 C 函数

本章介绍如何在 Prajna 中调用 C 函数。这样可复用大量 C/C++ 基础库。

### 声明外部函数

通过 `@extern` 标记函数，使其符号名与 C 函数一致。例如在 `test.prajna`：

```prajna
func TestA(); // 符号为 ::test::TestA，不能直接对应 C 函数

@extern
func TestB(); // 符号为 TestB，可对应 C 函数
```

声明外部函数后，需加载相关动态库。

### 加载动态库

用 `#link` 指令加载动态库（如 libzmq）：

```prajna
#link("libzmq");
```

需在 `libs` 目录下放置不同平台的动态库，结构如下：

```bash
libs/
├── linux/
│   └── libzmq.so
├── osx/
│   └── libzmq.dylib
└── win/
    └── libzmq.dll
```

详见 `examples/zmq`，该示例演示如何在 Prajna 中调用 C 的 libzmq 库，后续也将作为 Prajna 的 socket 通信库。

## 在 C++ 中调用 Prajna

考虑到 Prajna 生态初期尚不完善，官方也提供了在 C++ 中调用 Prajna 的示例。因此可先用 Prajna 实现部分功能，相关代码位于 `examples_in_cpp`。若需脱离源码独立使用，可能需做适当修改。
