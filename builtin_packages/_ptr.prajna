template <Type>
implement ptr<Type> {
    @static
    func Allocate(size: i64)->ptr<Type> {
        var re =  bit_cast<ptr<undef> ,ptr<Type>>(bindings::malloc(size * sizeof<Type>()));
        return re;
    }

    @static
    func New()->ptr<Type>{
        var t = ptr<Type>::Allocate(1);
        return t;
    }

    @static
    func Null()->ptr<Type> {
        return cast<i64, ptr<Type>>(0);
    }

    func Free() {
        bindings::free(bit_cast<ptr<Type>, ptr<undef>>(this));
        this = ptr<Type>::Null();
    }

    func ToInt64()->i64{
        return cast<ptr<Type>, i64>(this);
    }

    func IsNull()->bool{
        return this.ToInt64() == 0;
    }

    func IsValid()->bool {
        return !this.IsNull();
    }

    func __arrow__()->ptr<Type> {
        return this;
    }

    func __equal__(operand: ptr<Type>) -> bool {
        return this.ToInt64() == operand.ToInt64();
    }

    func __not_equal__(operand: ptr<Type>) -> bool {
        return !(this == operand);
    }

    // 这里可能导致Ptr里的歧义, 需要确认和下面没冲突
    // func __initialize__() {
    //     this = ptr<Type>::Null();
    // }
}

struct ControlBlock{
    strong_count: i64;
    weak_count: i64;
}

template <Type>
struct Ptr{
    raw_ptr: ptr<Type>;
    size: i64;
    _control_block: ptr<ControlBlock>;
}

template <Type>
implement Ptr<Type>{
    @static
    func Allocate(size: i64)->Ptr<Type>{
        var self: Ptr<Type>;
        self.raw_ptr =  ptr<Type>::Allocate(size);
        self.size = size;
        self._control_block = ptr<ControlBlock>::New();
        self._control_block->strong_count = 1;
        self._control_block->weak_count = 0;

        for i in 0 to size {
            initialize<Type>(&self.raw_ptr[i]);
        }

        return self;
    }

    @static
    func New()->Ptr<Type>{
        return Allocate(1);
    }

    @static
    func Null()->Ptr<Type>{
        var self: Ptr<Type>;
        self.raw_ptr = ptr<Type>::Null();
        self.size = 0;
        self._control_block = ptr<ControlBlock>::Null();
        return self;
    }

    func ToInt64()->i64{
        return this.raw_ptr.ToInt64();
    }

    // 因为内存计数是直接通过指针地址来记录的. 所以只要他们有相同的机制, 那么指针的传输, 转变不会导致错误.
    func ToUndef()->Ptr<undef>{
        var undef_ptr: Ptr<undef>;
        undef_ptr.raw_ptr = bit_cast<ptr<Type> ,ptr<undef>>(this.raw_ptr);
        undef_ptr._control_block = this._control_block;
        if (undef_ptr._control_block.IsValid()) {
            undef_ptr._control_block->strong_count = undef_ptr._control_block->strong_count + 1;
        }
        return undef_ptr;
    }

    @static
    func FromUndef(undef_ptr: Ptr<undef>)->Ptr<Type>{
        var self: Ptr<Type>;
        self.raw_ptr = bit_cast<ptr<undef> ,ptr<Type>>(undef_ptr.raw_ptr);
        self._control_block = undef_ptr._control_block;
        if (self._control_block.IsValid()) {
            self._control_block->strong_count = self._control_block->strong_count + 1;
        }
        return self;
    }

    func IsNull()->bool{
        return this.raw_ptr.IsNull();
    }

    func IsValid()->bool {
        return !this.IsNull();
    }

    func ReferenceCount()->i64 {
        if (this._control_block.IsNull()) {
            return 0;
        }
        return this._control_block->strong_count;
    }

    func WeakReferenceCount()->i64 {
        if (this._control_block.IsNull()) {
            return 0;
        }
        return this._control_block->weak_count;
    }

    template <Interface>
    func As()->Dynamic<Interface> {
        return __as<Type, Interface>(this);
    }

    func __arrow__()->ptr<Type> {
        return this.raw_ptr;
    }

    @inline
    func __get_linear_index__(index: i64)->Type {
        return  this.raw_ptr[index];
    }

    @inline
    func __set_linear_index__(index: i64, value: Type) {
        this.raw_ptr[index] = value;
    }

    func __equal__(operand: Ptr<Type>) -> bool {
        return this.ToInt64() == operand.ToInt64();
    }

    func __not_equal__(operand: Ptr<Type>) -> bool {
        return !(this == operand);
    }

    func __initialize__() {
        this.raw_ptr = ptr<Type>::Null();
        this._control_block = ptr<ControlBlock>::New();
        this._control_block->strong_count = 1;
        this._control_block->weak_count = 0;
        this.size = 0;
    }

    func __copy__() {
        if (this._control_block.IsValid()) {
            this._control_block->strong_count = this._control_block->strong_count + 1;
        }
    }

    func __finalize__() {
        if (this._control_block.IsValid()) {
            this._control_block->strong_count = this._control_block->strong_count - 1;
            if (this._control_block->strong_count == 0) {
                // 先折构，再释放内存
                if (this.IsValid()) {
                    for i in 0 to this.size {
                        finalize<Type>(&this.raw_ptr[i]);
                    }
                    this.raw_ptr.Free();
                }

                // 如果没有弱引用，也释放控制块
                if (this._control_block->weak_count <= 0) {
                    this._control_block.Free();
                }
            }
         }
    }

}

template <Type>
struct WeakPtr{
    raw_ptr: ptr<Type>;
    size: i64;
    _control_block: ptr<ControlBlock>;
}

template <Type>
implement WeakPtr<Type> {
    @static
    func FromPtr(shared: Ptr<Type>)->WeakPtr<Type> {
        var self: WeakPtr<Type>;
        self.raw_ptr = shared.raw_ptr;
        self.size = shared.size;
        self._control_block = shared._control_block;
        if (self._control_block.IsValid()) {
            self._control_block->weak_count = self._control_block->weak_count + 1;
        }
        return self;
    }

    @static
    func Null()->WeakPtr<Type> {
        var self: WeakPtr<Type>;
        self.raw_ptr = ptr<Type>::Null();
        self.size = 0;
        self._control_block = ptr<ControlBlock>::Null();
        return self;
    }

    func IsNull()->bool {
        return this.raw_ptr.IsNull();
    }

    func ToInt64()->i64{
        return this.raw_ptr.ToInt64();
    }

    func Lock()->Ptr<Type> {
        if (this._control_block.IsNull() || (this._control_block->strong_count == 0) || this.IsNull()) {
            return Ptr<Type>::Null();
        }

        var shared: Ptr<Type>;
        shared.raw_ptr = this.raw_ptr;
        shared.size = this.size;
        shared._control_block = this._control_block;
        shared._control_block->strong_count = shared._control_block->strong_count + 1;
        return shared;
    }

    func IsExpired()->bool {
        return this._control_block.IsNull() || (this._control_block->strong_count == 0) || this.IsNull();
    }

    func ReferenceCount()->i64 {
        if (this._control_block.IsNull()) {
            return 0;
        }
        return this._control_block->strong_count;
    }

    func WeakReferenceCount()->i64 {
        if (this._control_block.IsNull()) {
            return 0;
        }
        return this._control_block->weak_count;
    }

    template <Interface>
    func As()->Dynamic<Interface> {
        return __as<Type, Interface>(this);
    }

    func __arrow__()->ptr<Type> {
        return this.raw_ptr;
    }

    @inline
    func __get_linear_index__(index: i64)->Type {
        return  this.raw_ptr[index];
    }

    @inline
    func __set_linear_index__(index: i64, value: Type) {
        this.raw_ptr[index] = value;
    }

    func __equal__(operand: WeakPtr<Type>) -> bool {
        return this.ToInt64() == operand.ToInt64();
    }

    func __not_equal__(operand: WeakPtr<Type>) -> bool {
        return !(this == operand);
    }

    func __initialize__() {
        this.raw_ptr = ptr<Type>::Null();
        this._control_block = ptr<ControlBlock>::Null();
        this.size = 0;
    }

    func __copy__() {
        if (!this.IsNull() && this._control_block.IsValid()) {
            this._control_block->weak_count = this._control_block->weak_count + 1;
        }
    }

    func __finalize__() {
        if (!this.IsNull() && this._control_block.IsValid()) {
            this._control_block->weak_count = this._control_block->weak_count - 1;

            if ((this._control_block->strong_count == 0) && (this._control_block->weak_count == 0)) {
                this._control_block.Free();
            }
        }
    }

}